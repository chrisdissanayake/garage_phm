[
  {
    "objectID": "calibration.html#arduino",
    "href": "calibration.html#arduino",
    "title": "1  Calibration",
    "section": "1.1 Arduino",
    "text": "1.1 Arduino"
  },
  {
    "objectID": "calibration.html#python",
    "href": "calibration.html#python",
    "title": "1  Calibration",
    "section": "1.2 Python",
    "text": "1.2 Python"
  },
  {
    "objectID": "calibration.html#verify-adc",
    "href": "calibration.html#verify-adc",
    "title": "1  Calibration",
    "section": "1.2 Verify ADC",
    "text": "1.2 Verify ADC"
  },
  {
    "objectID": "calibration.html#axis",
    "href": "calibration.html#axis",
    "title": "1  Calibration",
    "section": "1.4 Axis",
    "text": "1.4 Axis"
  },
  {
    "objectID": "calibration.html#tilt-orientation",
    "href": "calibration.html#tilt-orientation",
    "title": "1  Calibration",
    "section": "1.5 Tilt Orientation",
    "text": "1.5 Tilt Orientation\nNeed to write the procedure.\n\npre_proc_tbl &lt;- function(file_name) {\n  d &lt;- read_table(str_glue(\"../data/{file_name}.txt\"), \n                  col_types = cols(.default = \"character\", \"X5\" = col_skip()),\n                  skip = 10)\n  col_names &lt;- c(\"time\", \"x\", \"y\", \"z\")\n  d &lt;- set_names(d, col_names)\n  \n  d &lt;- d |&gt; \n    mutate_if(is.character, .funs = as.numeric) |&gt; \n    mutate(time = as.numeric(time), \n           time = lubridate::milliseconds(time))  \n  \n  d &lt;- d |&gt; tidyr::drop_na()\n}\n\n\nd &lt;- pre_proc_tbl(\"garagedoor_home-1_bode\")\n\n\nimport numpy as np\nimport scipy.stats as ss\nfrom sklearn.metrics import mutual_info_score\n\ndef numBins(nObs, corr=None):\n    #optimal number of bins for discretization\n    if corr is None: #univariate case\n        z = (8+324*nObs+12*(36*nObs+729*nObs**2)**.5)**(1/3.)\n        b = round(z/6.+2./(3*z)+1./3)\n    else: #bivariate case\n        b = round(2**-.5*(1+(1+24*nObs/(1.-corr**2))**.5)**.5)\n    \n    return int(b)\n\ndef mutualInfor(x,y, norm=False):\n  #mutual information\n  bXY = numBins(x.shape[0], corr = np.corrcoef(x,y)[0,1])\n  cXY = np.histogram2d(x,y, bXY)[0]\n  iXY = mutual_info_score(None, None, contingency=cXY)\n  if norm:\n    hX = ss.entropy(np.histogram(x, bins)[0]) #marginal \n    hY = ss.entropy(np.histogram(y, bins)[0]) #marginal\n    iXY /= min(hX, hY) #normalized mutual information\n    \n  return iXY\n  \nx = r.d['x']\nx = np.array(x)\ny = r.d['y']\ny = np.array(y)\n\nbins=10 # descretize sample space\n\nnmi = mutualInfor(x,y,True)\ncorr = np.corrcoef(x,y)[0,1]\n\nd = {\"nmi\": nmi, \"corr\": corr}\nd\n\n#&gt; {'nmi': 0.19540919457977227, 'corr': -0.27134033163438037}\n\n\nmutual information is not a metric."
  },
  {
    "objectID": "preprocessing.html",
    "href": "preprocessing.html",
    "title": "3  Preprocessing Methods",
    "section": "",
    "text": "4 Median Filter\nThe data has irregular spike patterns caused by the slack of the curved door arm. A simple filter is used to remove them.\nThis is an automated procedure that cleans and segments the signal into idle, torsion coil, and impulse responses observed during operation.\nd &lt;- d |&gt; \n  mutate(z_smo = loess(z ~ time, span = 0.1)$fitted, \n         y_smo = loess(y ~ time, span = 0.1)$fitted) \n\nts_data &lt;- d |&gt; pull(z_smo) |&gt; ts()\n\nd |&gt; \n  pivot_longer(c(z, z_smo, y, y_smo)) |&gt; \n  ggplot(aes(time, value)) +\n  geom_point(size = 0.5) +\n  facet_wrap(~name) +\n  labs(title = \"Signal Smoothing\")"
  },
  {
    "objectID": "preprocessing.html#extract-orthogonal-locations",
    "href": "preprocessing.html#extract-orthogonal-locations",
    "title": "3  Preprocessing Methods",
    "section": "6.1 Extract Orthogonal Locations",
    "text": "6.1 Extract Orthogonal Locations\nI am using a machine learning method here to isolate the up and down slopes, which are the torsion coil unwinding and winding scenarios. Orthogonal here means that the garage door’s orientation to the ground, horizontal or vertical.\n\nimport statsmodels.api as sm1\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pylab as plt\nfrom sklearn import linear_model, datasets\n\n# Return the t-statistic for a given parameter estimate.\ndef tValLinR(close):\n    # tValue from a linear trend\n    x = np.ones((close.shape[0], 2))\n    x[:, 1] = np.arange(close.shape[0])\n    ols = sm1.OLS(close, x).fit()\n    return ols.tvalues[1]\n\n\ndef getBinsFromTrend(molecule, close, span):\n    '''\n    Derive labels from the sign of t-value of trend line\n    output includes:\n      - t1: End time for the identified trend\n      - tVal: t-value associated with the estimated trend coefficient\n      - bin: Sign of the trend\n    The t-statistics for each tick has a different look-back window.\n\n    - idx start time in look-forward window\n    - dt1 stop time in look-forward window\n    - df1 is the look-forward window\n    - iloc ?\n    '''\n    out = pd.DataFrame(index=molecule, columns=['t1', 'tVal', 'bin', 'windowSize'])\n    hrzns = range(*span)\n    windowSize = span[1] - span[0]\n    maxWindow = span[1] - 1\n    minWindow = span[0]\n    for idx in close.index:\n        idx += maxWindow\n        if idx &gt;= len(close):\n            break\n        df_tval = pd.Series(dtype='float64')\n        iloc0 = close.index.get_loc(idx)\n        # if iloc0+max(hrzns) &gt; close.shape[0]:\n        #    continue\n        for hrzn in hrzns:\n            dt1 = close.index[iloc0 - hrzn + 1]\n            df1 = close.loc[dt1:idx]\n            df_tval.loc[dt1] = tValLinR(df1.values)  # calculates t-statistics on period\n            dt1 = df_tval.replace([-np.inf, np.inf, np.nan],\n                              0).abs().idxmax()  # get largest t-statistics calculated over span period\n\n        # print(df_tval.index[-1])\n        # print(dt1)\n        # print(abs(df_tval.values).argmax() + minWindow)\n        out.loc[idx, ['t1', 'tVal', 'bin', 'windowSize']] = df_tval.index[-1], df_tval[dt1], np.sign(df_tval[dt1]), abs(\n            df_tval.values).argmax() + minWindow  # prevent leakage\n    out['t1'] = pd.to_datetime(out['t1'])\n    out['bin'] = pd.to_numeric(out['bin'], downcast='signed')\n\n    # deal with massive t-Value outliers - they dont provide more confidence and they ruin the scatter plot\n    tValueVariance = out['tVal'].values.var()\n    tMax = 20\n    if tValueVariance &lt; tMax:\n        tMax = tValueVariance\n\n    out.loc[out['tVal'] &gt; tMax, 'tVal'] = tMax  # cutoff tValues &gt; 20\n    out.loc[out['tVal'] &lt; (-1) * tMax, 'tVal'] = (-1) * tMax  # cutoff tValues &lt; -20\n    return out.dropna(subset=['bin'])\n\n\n\nidx_range_from = 5\nidx_range_to = 10\ndf0 = pd.Series(r.ts_data)\n\nspan = [idx_range_from,idx_range_to,1] # [3,10,1] = range(3,10)\n\ndf1 = getBinsFromTrend(df0.index, df0, span) \ntValues = df1['tVal'].values\n\n\nlibrary(reticulate)\n\nd_f &lt;- py$df1 |&gt; \n  rownames_to_column(\"id\") |&gt; \n  unnest(tVal) \n\nd_fmerg &lt;- d |&gt; \n  rownames_to_column(\"id\") |&gt; \n  left_join(d_f) |&gt;\n  tidyr::fill(bin, .direction = \"downup\") |&gt; \n  mutate(id = as.numeric(id)) |&gt; \n  na.omit() |&gt; \n  mutate(run_id = consecutive_id(bin)) |&gt; \n  group_by(run_id) |&gt; \n  mutate(bin = ifelse(n() &lt; 1000, 0, bin))\n\nd_fmerg |&gt; \n  ggplot(aes(id, z, col = as.factor(bin))) +\n  geom_point(size = 0.3) +\n  labs(x = \"time (s)\", \n       y = \"Calibrated Value\", \n       col = \"Recipe Step\")\n\n\n\n\nThis works for other examples as well.\nHere is the nomenclature:\n\n0 = horizontal or vertical position\n-1 = torsion coil winding\n1 = torsion coil unwinding"
  },
  {
    "objectID": "preprocessing.html#extract-door-idle-locations",
    "href": "preprocessing.html#extract-door-idle-locations",
    "title": "3  Preprocessing Methods",
    "section": "6.2 Extract Door Idle Locations",
    "text": "6.2 Extract Door Idle Locations\nThe door can be idle in orthogonal locations, and I am fitting a simple dependent mixture model here.\n\nlibrary(depmixS4)\n\nset.seed(123)\n\nhmm_model &lt;- depmixS4::depmix(data = d_fmerg, nstates = 2, z_smo~z)\nhmm_fit &lt;- fit(hmm_model)\n\n#&gt; converged at iteration 36 with logLik: 24001\n\n# hmm_fit@transition\n\n# plot(ts(posterior(hmm_fit, type = \"smoothing\")), ylab = \"probability\", frame = FALSE)"
  },
  {
    "objectID": "preprocessing.html#results",
    "href": "preprocessing.html#results",
    "title": "3  Preprocessing Methods",
    "section": "6.3 Results",
    "text": "6.3 Results\n\nd_fmerg_final &lt;- d_fmerg |&gt; \n  ungroup() |&gt; \n  bind_cols(smo_prob = posterior(hmm_fit, type = \"smoothing\")[,1]) |&gt; \n  mutate(bin_hmm = ifelse(smo_prob &gt; 0.999, \"transition\", \"idle\")) |&gt; \n  mutate(run_idle_id = consecutive_id(bin_hmm)) |&gt; \n  group_by(run_idle_id) |&gt; \n  mutate(numbers = n(),\n         bin_hmm = ifelse(n() &lt; 200 , \"transition\", bin_hmm)) |&gt; \n  mutate(recipe_step = paste(bin_hmm, bin))\n\n\nd_fmerg_final |&gt;\n  pivot_longer(c(x, y, z)) |&gt;\n  ggplot(aes(time, value, col = as.factor(recipe_step))) +\n  geom_point(size = 0.3) +\n  facet_wrap(~name) +\n  labs(x = \"time (s)\",\n       y = \"Calibrated Value\",\n       col = \"recipe step\")\n\n\n\n\nPerfect!"
  },
  {
    "objectID": "datacollection.html",
    "href": "datacollection.html",
    "title": "2  Query Data",
    "section": "",
    "text": "Data is stored in two AWS RDS databases. Please let me know if you have lost the credentials.\n\ngd_phm_status : This has the model output information, hardware maintenance information, versioning, and configuration settings.\nmetrics : This hosts accuracy and reliability metrics for other all my projects. The table for this project is called “gd_phm”.\n\nShown below is a generic sequence.\nMake a connection:\n\ncon &lt;- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"gd_phm_status\",\n  host = Sys.getenv(\"gd_db_host\"),\n  port = 5432,\n  user = Sys.getenv(\"gd_db_user\"),\n  password = Sys.getenv(\"gd_db_pw\")\n)\n\nGet all relevant table names:\n\ntbl &lt;- DBI::dbGetQuery(\n  conn = con,\n  \"SELECT table_name\n  FROM information_schema.tables\n  WHERE table_name like '%gd%'\n\"\n)\n\ntbl |&gt; pull(table_name) |&gt; cat(sep = \", \")\n\n#&gt; gd_meas_tbl, gd_config_hw_tbl, gd_config_models_tbl\n\n\nPull data:\n\ntbl &lt;- DBI::dbGetQuery(\n  conn = con,\n  \n  \"WITH joined_tbl AS (\n    SELECT\n      gd_config_hw_tbl.*,\n      meas_date,\n      meas_seq,\n      status,\n      gd_meas_tbl.model AS model,\n      prob,\n      model_version,\n      version_from,\n      version_to\n    FROM gd_config_hw_tbl\n    INNER JOIN gd_meas_tbl\n      ON (gd_config_hw_tbl.location_id = gd_meas_tbl.location_id)\n    INNER JOIN gd_config_models_tbl\n      ON (\n        gd_config_hw_tbl.location_id = gd_config_models_tbl.location_id AND\n        gd_meas_tbl.model = gd_config_models_tbl.model\n         )\n    )\n  \n  SELECT\n    state,\n    city_code,\n    location_id,\n    model,\n    model_version,\n    meas_date,\n    MAX(prob) AS prob_max\n  FROM joined_tbl\n  WHERE (meas_date &gt;= version_from AND ((version_to IS NULL) OR meas_date &lt;= version_to))\n  GROUP BY state, city_code, location_id, model, model_version, meas_date;\"\n)\n\ntbl |&gt; head(10)\n\n#&gt;    state city_code location_id    model model_version  meas_date  prob_max\n#&gt; 1     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-12 0.0008547\n#&gt; 2     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-13 0.0014096\n#&gt; 3     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-14 0.0009876\n#&gt; 4     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-15 0.0023421\n#&gt; 5     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-15 0.0023421\n#&gt; 6     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-16 0.0069242\n#&gt; 7     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-17 0.0062839\n#&gt; 8     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-18 0.0352436\n#&gt; 9     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-19 0.0210955\n#&gt; 10    MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-20 0.0015077\n\n\nMake a plot:\n\ntbl |&gt; \n  filter(meas_date &lt; as.Date(\"2023-06-11\")) |&gt; \n  mutate(model = ifelse(model == \"arm_brkt\", \"Arm Bracket Fault\", model)) |&gt; \n  ggplot(aes(meas_date, prob_max, col = model_version)) +\n  geom_point() +\n  facet_grid(location_id~ model, scales = \"free\") +\n  scale_x_date(date_breaks = \"2 weeks\") +\n  labs(\n    title = \"Daily Maximum Fault Probability for Each IoT Device Monitored Against Model Version\", \n    x = \"Date\", \n    y = \"Fault Probability\",\n    col = \"Model Version\"\n      )\n\n\n\n\nImportant! Please close the connection after you are done.\n\ndbDisconnect(con)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Garage Door Prognostics and Health Management",
    "section": "",
    "text": "Introduction\nWelcome to the work in progress documentation for the “Garage Door PHM” project.\nObjectives:\nThis is currently not the top priority for me. There are many other tasks that take precedence frequently.\nThat being said, this will continue to evolve in between many changes I make for both hardware and software. I plan on spending a few hours every week here, which I think would ultimately benefit the project."
  },
  {
    "objectID": "index.html#note-on-code-folding",
    "href": "index.html#note-on-code-folding",
    "title": "Garage Door Prognostics and Health Management",
    "section": "Note on Code Folding",
    "text": "Note on Code Folding\nI will leave the code blocks open by default, but there will be instances where code folding would warrant. If this is the case, you could easily unfold them by clicking an arrow above the output.\nFor example,\n\n\nCode\nmtcars |&gt; \n  ggplot(aes(disp, mpg, col = factor(cyl))) +\n  geom_point() +\n  labs(title = \"mpg vs dispacement\", \n       col = \"number of cylinders\")"
  },
  {
    "objectID": "index.html#session-information",
    "href": "index.html#session-information",
    "title": "Garage Door Prognostics and Health Management",
    "section": "Session Information",
    "text": "Session Information\nEverything on this documentation is reproducible. The code and data are here.\nR: R version 4.3.1 (2023-06-16)\nRust: rustc 1.68.2 (9eb3afe9e 2023-03-27)\nPython: Python 3.9.13\nC++: gcc (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0, Copyright (C) 2021 Free Software Foundation, Inc., This is free software; see the source for copying conditions. There is NO, warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.,"
  },
  {
    "objectID": "index.html#how-this-is-organized",
    "href": "index.html#how-this-is-organized",
    "title": "Garage Door Prognostics and Health Management",
    "section": "How this is organized",
    "text": "How this is organized\nArranged by function to assist troubleshooting."
  },
  {
    "objectID": "index.html#system-configuration",
    "href": "index.html#system-configuration",
    "title": "Garage Door Prognostics and Health Management",
    "section": "System Configuration",
    "text": "System Configuration\n\n\n\n\n\n\n\n\n\n\ngraph TB\nA(Accelerometer)--&gt;AA \n\nsubgraph Future-Replace\nAA[Arduino]--&gt;E[Thin Client]\nstyle Future-Replace fill:#f0f0f0,stroke:grey,stroke-width:2px\nend\n\nE--&gt;F[AWS RDS]\nF--&gt;FF[Decisions / Notifications]\nF--&gt;G(\"Dashboard &lt;/br&gt;(Metrics, Sensor Data,  Decisions)\")\nFF-.-&gt;G\nGD(Garage Door) -.-&gt; A\nstyle G fill:#B6E6E6\nstyle GD fill:salmon \nstyle E stroke:blue,stroke-width:3px\n\nsubgraph Thin-Client\nBB((Every &lt;/br&gt; 2 Hours))--&gt;CA[Gather Data]\nBB--&gt;CAA[Preprocess]\nCAA--&gt;CAAB{Door Activity?}\nCAAB--Yes--&gt;CBB[Run Models]\nCAAB--No--&gt;CAAC(End)\nCBB--&gt;CB[Data / Results]\nstyle BB fill:salmon \nstyle Thin-Client fill:#f0f0f0,stroke:blue,stroke-width:3px\nend"
  },
  {
    "objectID": "calibration.html#adxl335",
    "href": "calibration.html#adxl335",
    "title": "2  Installation and Calibration",
    "section": "2.2 ADXL335",
    "text": "2.2 ADXL335\nThe ADXL335 is a triaxial accelerometer with three analog outputs that correspond to the orthogonal X, Y, and Z axes. The accelerometer responds to tilt, and since it is mounted in parallel to the door (reference), this measurement translates to a dynamic angle of incline.\nThe technical datasheet for ADXL335 is here."
  },
  {
    "objectID": "calibration.html#preliminary-calibration",
    "href": "calibration.html#preliminary-calibration",
    "title": "2  Installation and Calibration",
    "section": "2.2 Preliminary Calibration",
    "text": "2.2 Preliminary Calibration\n\nThe calibration procedure is explained here. This also serves as a secondary purpose of verifying the functionality of the accelerometer.\n\n#include &lt;math.h&gt;\nconst int x_out = A0; \nconst int y_out = A1; \nconst int z_out = A2; \n\nunsigned long tms;\n\nvoid setup() {\n  Serial.begin(115200); \n}\n\nvoid loop() {\n  int x_adc_value, y_adc_value, z_adc_value; \n  \n  x_adc_value = analogRead(x_out);  \n  y_adc_value = analogRead(y_out);  \n  z_adc_value = analogRead(z_out);  \n\n//  Serial.print(\"x = \");\n//  Serial.print(x_adc_value);\n//  Serial.print(\"\\t\\t\");\n//  Serial.print(\"y = \");\n//  Serial.print(y_adc_value);\n//  Serial.print(\"\\t\\t\");\n//  Serial.print(\"z = \");\n//  Serial.print(z_adc_value);\n//  Serial.println(\"\\t\\t\");\n\n// Right hand rule is constrained\n\n  int x = map(x_adc_value, 264, 396, -100, 100);\n  float xg = (float)x/(-100.00);\n  \n  int y = map(y_adc_value, 267, 400, -100, 100);\n  float yg = (float)y/(-100.00);\n\n  int z = map(z_adc_value, 275, 410, -100, 100);\n  float zg = (float)z/(-100.00);\n\n\n// CW is positive\n\ndouble tilt_fc, tilt_tw;\n\n//  tilt_X =atan2(-yg,-zg)*57.2957795; /* yaw dof cannot be measured */ \n  tilt_fc = -1*atan2(xg,yg)*57.2957795; /* across the face of the door */\n  tilt_tw = -1*atan2(zg,yg)*57.2957795; /* towards and back */\n  \n\n  tms = millis();\n\n  Serial.print(tms); \n  Serial.print(\"\\t\");\n  Serial.print(xg);\n  Serial.print(\"\\t\");\n  Serial.print(yg);\n  Serial.print(\"\\t\");\n  Serial.print(zg);\n  Serial.print(\"\\t\");\n  Serial.print(tilt_fc);\n  Serial.print(\"\\t\");\n  Serial.print(tilt_tw);\n  Serial.print(\"\\n\");\n  \n//  delay(1000);\n\n}"
  },
  {
    "objectID": "calibration.html#tilt-orientation-calibration",
    "href": "calibration.html#tilt-orientation-calibration",
    "title": "2  Calibration",
    "section": "2.3 Tilt Orientation Calibration",
    "text": "2.3 Tilt Orientation Calibration\nThe door moves is relative to the left and right tracks, and this can cause many problems if the accelerometer is not positioned correctly.\n\n2.3.1 Install Adjustable Mount\nThe accelerometer mount is adjustable, and can be installed closer to the arm bracket, the closer the better. The reference tilt angle (tilt_fc) can be adjusted by loosening the M3 screws.\n\n\n \n\n\nHere are three outputs for three angles, -17 deg (CCW), 0 deg, and 17 deg (CW).\n\np_1 &lt;- pre_proc_tbl(\"angle-ccw17\") |&gt; \n  plot_ad() +\n  labs(title = \"-17 deg\") +\n  theme(axis.title = element_blank())\n\np_2 &lt;- pre_proc_tbl(\"2023-06-10_garagedoor-1\") |&gt; \n  plot_ad() +\n  labs(title = \"0 deg\") +\n  theme(axis.title = element_blank())\n\np_3 &lt;- pre_proc_tbl(\"angle-cw17\") |&gt; \n  plot_ad() +\n  labs(title = \"+17 deg\") +\n  theme(axis.title = element_blank())\n\np &lt;- p_1 /p_2/ p_3 \n\ngt &lt;- patchwork::patchworkGrob(p)\ngridExtra::grid.arrange(gt, left = \"Acceleration (g)\", bottom = \"time (s)\")\n\n\n\n\n\n\n2.3.2 Run Algorithm\nThe following procedure is a solution to this problem, proposed to exploit the nonlinear dependence between sensor variables, namely x-y and x-z. The solution also works without any preprocessing, which is also an advantage.\nBelow is an example calculation for the mutual information between x and y for the signal at 0 degrees. A lower value indicates better “alignment”.\n\nd &lt;- pre_proc_tbl(\"2023-06-10_garagedoor-1\") \n\n\nimport numpy as np\nimport scipy.stats as ss\nfrom sklearn.metrics import mutual_info_score\n\ndef numBins(nObs, corr=None):\n    #optimal number of bins for discretization\n    if corr is None: #univariate case\n        z = (8+324*nObs+12*(36*nObs+729*nObs**2)**.5)**(1/3.)\n        b = round(z/6.+2./(3*z)+1./3)\n    else: #bivariate case\n        b = round(2**-.5*(1+(1+24*nObs/(1.-corr**2))**.5)**.5)\n    \n    return int(b)\n\ndef mutualInfor(x,y, norm=False):\n  #mutual information\n  bXY = numBins(x.shape[0], corr = np.corrcoef(x,y)[0,1])\n  cXY = np.histogram2d(x,y, bXY)[0]\n  iXY = mutual_info_score(None, None, contingency=cXY)\n  if norm:\n    hX = ss.entropy(np.histogram(x, bins)[0]) #marginal \n    hY = ss.entropy(np.histogram(y, bins)[0]) #marginal\n    iXY /= min(hX, hY) #normalized mutual information\n    \n  return iXY\n\nx = r.d['x']\nx = np.array(x)\n\ny = r.d['y']\ny = np.array(y)\n\nbins=10 # descretize sample space\n\nnmi = mutualInfor(x,y,True)\n\nd = {\"nmi\": nmi}\n\nd\n\n#&gt; {'nmi': 0.46746092071197676}\n\n\n\n\n2.3.3 Evaluate Results\nTo determine the most optimal angle, a sweep needs to be done at varying increments. Typically, this is done within a range of approximately ±10 degrees.\n\nd_long &lt;- read_csv(\"../data/mu-i_angle_swp.csv\") %&gt;%\n  pivot_longer(cols = c(\"xy\", \"yz\", \"xz\"), names_to = \"name\", values_to = \"value\")\n\npreds &lt;- list()\nfor (name_2 in unique(d_long$name)) {\n  nd &lt;- d_long |&gt; dplyr::filter(name == name_2)\n  mars_model &lt;- earth::earth(value ~ angle, data = nd, nk = 3)\n  preds[[name_2]] &lt;- mars_model |&gt; predict()\n}\n\nangles &lt;- d_long |&gt; \n  filter(name == \"xy\") |&gt; \n  pull(angle)\n\npreds_df &lt;- data.frame(name = rep(names(preds), sapply(preds, length)),\n                 value = unlist(preds), angle =  angles)\n\nd_long |&gt; \n  ggplot(aes(angle, value, col = name)) +\n  geom_point() +\n  geom_line(data = preds_df, aes(angle, value)) +\n  scale_x_continuous(breaks = scales::pretty_breaks(n = 20)) +\n  labs(x = \"Angle (deg)\", \n       y = \"Mutual Information\" ,\n       col = \"Variables\", \n       title = \"Angle Sweep Results\")\n\n\n\n\nThe curve typically follows a hinge function. In our example, it may not be appropriate to select the zero degree position, and it is recommended to re-measure the top three angles. For this instance, the sensor was positioned at a five-degree clockwise (CW) offset."
  },
  {
    "objectID": "preprocessing.html#final-results",
    "href": "preprocessing.html#final-results",
    "title": "3  Preprocessing Methods",
    "section": "3.4 Final Results",
    "text": "3.4 Final Results\n\nd_fmerg_final &lt;- d_fmerg |&gt; \n  ungroup() |&gt; \n  bind_cols(smo_prob = posterior(hmm_fit, type = \"smoothing\")[,1]) |&gt; \n  mutate(bin_hmm = ifelse(smo_prob &gt; 0.999, \"Transition\", \"Idle\")) |&gt; \n  mutate(run_idle_id = consecutive_id(bin_hmm)) |&gt; \n  group_by(run_idle_id) |&gt; \n  mutate(numbers = n(),\n         bin_hmm = ifelse(n() &lt; 2000 , \"Transition\", bin_hmm)) |&gt; \n  mutate(recipe_step = paste(bin_hmm, bin))\n\n\nd_fmerg_final |&gt; \n  pivot_longer(c(x, y, z)) |&gt;\n  ggplot(aes(time, value, col = as.factor(recipe_step))) +\n  geom_point(size = 0.3) +\n  facet_wrap(~name) +\n  labs(x = \"time (s)\",\n       y = \"Acceleration (g)\",\n       col = \"Recipe Step\")\n\n\n\n\nThe sensor position around the turn (pink, door going up) has a distinct signature compared to the opposite (green, door coming down).\nThe shape of the signal comes from the rate of tilt around the turn, denoted by ((t)), and can be expressed by a the following first order differential equation:\n\\[\n\\frac{d\\theta}{dt} = f(\\theta, G, t),\n\\]\nwhere (f(, G, t)) represents the function describing the dynamics of the garage door, and G is the geometry of the system. This function is unknown, but can be expressed for the simplest case as\n\\[\n\\frac{d\\theta}{dt} =\\dot{\\theta}\\ = k\\theta,\n\\]\nwhich states that the rate of change of the angular position of the accelerometer Y and Z axis is proportional to the current angular position (\\(\\dot{\\theta}/θ = k\\)). The general solution to this equation is\n\\[\n\\theta \\ =  Ce^{kt},\n\\] where C is a constant that depends on the initial conditions of the system. This is one of the reasons why the adjustment for the angle sweep using the adjustable mount is important."
  },
  {
    "objectID": "datacollection.html#make-a-connection",
    "href": "datacollection.html#make-a-connection",
    "title": "5  Query Stored Data",
    "section": "5.1 Make a Connection",
    "text": "5.1 Make a Connection\n\ncon &lt;- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"gd_phm_status\",\n  host = Sys.getenv(\"gd_db_host\"),\n  port = 5432,\n  user = Sys.getenv(\"gd_db_user\"),\n  password = Sys.getenv(\"gd_db_pw\")\n)"
  },
  {
    "objectID": "datacollection.html#get-relevant-table-names",
    "href": "datacollection.html#get-relevant-table-names",
    "title": "5  Query Stored Data",
    "section": "5.2 Get Relevant Table Names",
    "text": "5.2 Get Relevant Table Names\n\ntbl &lt;- DBI::dbGetQuery(\n  conn = con,\n  \"SELECT table_name\n  FROM information_schema.tables\n  WHERE table_name like '%gd%'\n\"\n)\n\ntbl |&gt; pull(table_name) |&gt; cat(sep = \", \")\n\n#&gt; gd_meas_tbl, gd_config_hw_tbl, gd_config_models_tbl"
  },
  {
    "objectID": "datacollection.html#pull-data",
    "href": "datacollection.html#pull-data",
    "title": "5  Query Stored Data",
    "section": "5.3 Pull Data",
    "text": "5.3 Pull Data\n\ntbl &lt;- DBI::dbGetQuery(\n  conn = con,\n  \n  \"WITH joined_tbl AS (\n    SELECT\n      gd_config_hw_tbl.*,\n      meas_date,\n      meas_seq,\n      status,\n      gd_meas_tbl.model AS model,\n      prob,\n      model_version,\n      version_from,\n      version_to\n    FROM gd_config_hw_tbl\n    INNER JOIN gd_meas_tbl\n      ON (gd_config_hw_tbl.location_id = gd_meas_tbl.location_id)\n    INNER JOIN gd_config_models_tbl\n      ON (\n        gd_config_hw_tbl.location_id = gd_config_models_tbl.location_id AND\n        gd_meas_tbl.model = gd_config_models_tbl.model\n         )\n    )\n  \n  SELECT\n    state,\n    city_code,\n    location_id,\n    model,\n    model_version,\n    meas_date,\n    MAX(prob) AS prob_max\n  FROM joined_tbl\n  WHERE (meas_date &gt;= version_from AND ((version_to IS NULL) OR meas_date &lt;= version_to))\n  GROUP BY state, city_code, location_id, model, model_version, meas_date;\"\n)\n\ntbl |&gt; head(10)\n\n#&gt;    state city_code location_id    model model_version  meas_date  prob_max\n#&gt; 1     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-12 0.0008547\n#&gt; 2     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-13 0.0014096\n#&gt; 3     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-14 0.0009876\n#&gt; 4     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-15 0.0023421\n#&gt; 5     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-15 0.0023421\n#&gt; 6     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-16 0.0069242\n#&gt; 7     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-17 0.0062839\n#&gt; 8     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-18 0.0352436\n#&gt; 9     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-19 0.0210955\n#&gt; 10    MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-20 0.0015077"
  },
  {
    "objectID": "datacollection.html#plot-data",
    "href": "datacollection.html#plot-data",
    "title": "5  Query Stored Data",
    "section": "5.4 Plot Data",
    "text": "5.4 Plot Data\n\ntbl |&gt; \n  filter(meas_date &lt; as.Date(\"2023-06-11\")) |&gt; \n  mutate(model = ifelse(model == \"arm_brkt\", \"Arm Bracket Fault\", model)) |&gt; \n  ggplot(aes(meas_date, prob_max, col = model_version)) +\n  geom_point() +\n  facet_grid(location_id~ model, scales = \"free\") +\n  scale_x_date(date_breaks = \"2 weeks\") +\n  labs(\n    title = \"Daily Maximum Fault Probability for Each IoT Device Monitored Against Model Version\", \n    x = \"Date\", \n    y = \"Fault Probability\",\n    col = \"Model Version\"\n      )"
  },
  {
    "objectID": "datacollection.html#important",
    "href": "datacollection.html#important",
    "title": "5  Query Stored Data",
    "section": "5.5 Important!",
    "text": "5.5 Important!\nPlease close the connection after querying.\n\ndbDisconnect(con)"
  },
  {
    "objectID": "preprocessing.html#extract-torsion-coil-response",
    "href": "preprocessing.html#extract-torsion-coil-response",
    "title": "3  Preprocessing Methods",
    "section": "5.1 Extract Torsion Coil Response",
    "text": "5.1 Extract Torsion Coil Response\nMachine learning method to isolate the torsion coil unwinding and winding scenarios.\n\nimport statsmodels.api as sm1\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pylab as plt\nfrom sklearn import linear_model, datasets\n\n# Return the t-statistic for a given parameter estimate.\ndef tValLinR(close):\n    # tValue from a linear trend\n    x = np.ones((close.shape[0], 2))\n    x[:, 1] = np.arange(close.shape[0])\n    ols = sm1.OLS(close, x).fit()\n    return ols.tvalues[1]\n\n\ndef getBinsFromTrend(molecule, close, span):\n    '''\n    Derive labels from the sign of t-value of trend line\n    output includes:\n      - t1: End time for the identified trend\n      - tVal: t-value associated with the estimated trend coefficient\n      - bin: Sign of the trend\n    The t-statistics for each tick has a different look-back window.\n\n    - idx start time in look-forward window\n    - dt1 stop time in look-forward window\n    - df1 is the look-forward window\n    - iloc ?\n    '''\n    out = pd.DataFrame(index=molecule, columns=['t1', 'tVal', 'bin', 'windowSize'])\n    hrzns = range(*span)\n    windowSize = span[1] - span[0]\n    maxWindow = span[1] - 1\n    minWindow = span[0]\n    for idx in close.index:\n        idx += maxWindow\n        if idx &gt;= len(close):\n            break\n        df_tval = pd.Series(dtype='float64')\n        iloc0 = close.index.get_loc(idx)\n        # if iloc0+max(hrzns) &gt; close.shape[0]:\n        #    continue\n        for hrzn in hrzns:\n            dt1 = close.index[iloc0 - hrzn + 1]\n            df1 = close.loc[dt1:idx]\n            df_tval.loc[dt1] = tValLinR(df1.values)  # calculates t-statistics on period\n            dt1 = df_tval.replace([-np.inf, np.inf, np.nan],\n                              0).abs().idxmax()  # get largest t-statistics calculated over span period\n\n        # print(df_tval.index[-1])\n        # print(dt1)\n        # print(abs(df_tval.values).argmax() + minWindow)\n        out.loc[idx, ['t1', 'tVal', 'bin', 'windowSize']] = df_tval.index[-1], df_tval[dt1], np.sign(df_tval[dt1]), abs(\n            df_tval.values).argmax() + minWindow  # prevent leakage\n    out['t1'] = pd.to_datetime(out['t1'])\n    out['bin'] = pd.to_numeric(out['bin'], downcast='signed')\n\n    # deal with massive t-Value outliers - they dont provide more confidence and they ruin the scatter plot\n    tValueVariance = out['tVal'].values.var()\n    tMax = 20\n    if tValueVariance &lt; tMax:\n        tMax = tValueVariance\n\n    out.loc[out['tVal'] &gt; tMax, 'tVal'] = tMax  # cutoff tValues &gt; 20\n    out.loc[out['tVal'] &lt; (-1) * tMax, 'tVal'] = (-1) * tMax  # cutoff tValues &lt; -20\n    return out.dropna(subset=['bin'])\n\n\n\nidx_range_from = 5\nidx_range_to = 10\ndf0 = pd.Series(r.ts_data)\n\nspan = [idx_range_from,idx_range_to,1] # [3,10,1] = range(3,10)\n\ndf1 = getBinsFromTrend(df0.index, df0, span) \ntValues = df1['tVal'].values\n\n\nlibrary(reticulate)\n\nd_f &lt;- py$df1 |&gt; \n  rownames_to_column(\"id\") |&gt; \n  unnest(tVal) \n\nd_fmerg &lt;- d |&gt; \n  rownames_to_column(\"id\") |&gt; \n  left_join(d_f) |&gt;\n  tidyr::fill(bin, .direction = \"downup\") |&gt; \n  mutate(id = as.numeric(id)) |&gt; \n  na.omit() |&gt; \n  mutate(run_id = consecutive_id(bin)) |&gt; \n  group_by(run_id) |&gt; \n  mutate(bin = ifelse(n() &lt; 1000, 0, bin))\n\nd_fmerg |&gt; \n  ggplot(aes(id, z, col = as.factor(bin))) +\n  geom_point(size = 0.3) +\n  labs(x = \"time (s)\", \n       y = \"Calibrated Value\", \n       col = \"Recipe Step\")\n\n\n\n\nLegend definitions:\n\n0 = horizontal or vertical position\n-1 = torsion coil winding\n1 = torsion coil unwinding"
  },
  {
    "objectID": "preprocessing.html#extract-door-idle-response",
    "href": "preprocessing.html#extract-door-idle-response",
    "title": "3  Preprocessing Methods",
    "section": "5.2 Extract Door Idle Response",
    "text": "5.2 Extract Door Idle Response\nTo extract information about whether the door is idle up or down, a simple dependent mixture model is used.\n\nlibrary(depmixS4)\n\nset.seed(123)\n\nhmm_model &lt;- depmixS4::depmix(data = d_fmerg, nstates = 2, y_smo~y)\nhmm_fit &lt;- fit(hmm_model)\n\n#&gt; converged at iteration 21 with logLik: 40562\n\n# hmm_fit@transition\n\n# plot(ts(posterior(hmm_fit, type = \"smoothing\")), ylab = \"probability\", frame = FALSE)"
  },
  {
    "objectID": "model_arm_brkt.html",
    "href": "model_arm_brkt.html",
    "title": "3  Arm Bracket Fault Detection",
    "section": "",
    "text": "4 Hilbert Huang Transform\n\nget_imf_energies &lt;- function(tbl, measurement_function = \"x\") {\n  sig &lt;- tbl %&gt;% pull({{ measurement_function }})\n  tt &lt;- tbl %&gt;% pull(new_sensor_dt)\n  \n  inputimfs &lt;-  Sig2IMF(sig, tt, max.imf = 3)$imf # note max IMF \n  n_cols &lt;- ncol(inputimfs)\n  n_rows &lt;- nrow(inputimfs)\n  if (is.null(n_cols)) return(tibble())\n  # mse_hilbert = sum(inputimfs[,1]^2)/n_rows\n  # ek = NULL\n  # for (i in 1:n_cols) ek &lt;- c(ek, mse_hilbert*2.01^(-i)/0.719) # https://link.springer.com/chapter/10.1007/978-3-030-89010-0_8\n  #\n  \n  # sample_ek = NULL\n  # for (i in 1:n_cols) sample_ek &lt;- c(sample_ek, sum(inputimfs[,i]^2)/n_rows)\n  \n  sample_ek &lt;- apply(inputimfs, 2, function(x){sum(x^2)/n_rows})\n  \n  tibble(n = 1:n_cols \n         # \"ek\" = ek\n  ) %&gt;% \n    mutate(\n      log_eek = log(sample_ek)/log(2)\n    ) %&gt;% \n    return()\n}\n\n\nget_mm_results &lt;- function(tf_object_tool, measurement_function) {\n  .create_objects_for_model &lt;- function(tf_object_tool, measurement_function) {\n    tf_object_tool &lt;- tf_object_tool %&gt;%\n      unnest(gi) %&gt;% \n      ungroup()\n    \n    tf_object_tool &lt;- tf_object_tool %&gt;% \n      unnest(str_glue(\"ie_{measurement_function}\")) %&gt;% \n      select(id, recipe_step_start, n, log_eek, {{ measurement_function }}) %&gt;%\n      filter(n() &gt;= 2) %&gt;% \n      pivot_wider(values_from = log_eek, names_from = n) %&gt;%\n      drop_na(`1`, `2`)\n      \n      fml = str_glue(\"{measurement_function} ~ `2`\") %&gt;% formula()\n      \n      list(tf_object_tool = tf_object_tool, fml = fml)\n  } \n  \n  .create_mm_model &lt;- function(model_objects) {\n    n &lt;- labels(terms(model_objects$fml)) %&gt;% length() \n    \n    ms_ols_model &lt;- lm(formula = model_objects$fml,\n                       data  = model_objects$tf_object_tool) \n    \n    ms_model &lt;- msmFit(ms_ols_model,\n                       k = 2,\n                       p = 0,\n                       sw = rep(TRUE, n + 2), \n                       control = list(trace = FALSE, parallelization = TRUE))\n  }\n  \n  .process_mm_model &lt;- function(model_objects, ms_model, measurement_function) {\n    smoTransMatrob &lt;- model_objects$tf_object_tool %&gt;%  \n      select(id, recipe_step_start, {{ measurement_function }}) %&gt;% add_row(id = NA,  .before = 1) %&gt;%\n      cbind(. ,ms_model@Fit@smoProb)\n    \n    fault_regime &lt;- get_fault_regime(smoTransMatrob, measurement_function)\n    \n    list(smoTransMatrob = smoTransMatrob,\n         smoTransMat = ms_model@Fit@smoTransMat, \n         k = ms_model@k, \n         fault_regime = fault_regime)\n  }\n  \n  model_objects &lt;- .create_objects_for_model(tf_object_tool, measurement_function)\n  ms_model &lt;- .create_mm_model(model_objects)\n  \n  .process_mm_model(model_objects, ms_model, measurement_function)\n}\n\n\nget_model_with_status &lt;- function(location_id, \n                                  model_code,\n                                  print_error = TRUE,\n                                  model = \"mm_arm_brkt\",\n                                  object = \"smoTransMatrob\") {\n  \n  .print_err &lt;- function(message = \"Error\", print_error = TRUE){\n    if (print_error) print(str_glue(\"{message} in {location_id}\")) \n    return(NULL) \n  }\n  \n  models_tool %&gt;%\n    pull({{ model }}) %&gt;% \n    pluck(1, object) %||% .print_err(print_error = print_error)\n}\n\n\nmodel_status_definitions &lt;- function(type) {\n  switch(type,\n         \"named list\" = NA, # success\n         \"list\" = NA, # missing in configuration\n         \"lgl\" = \"Error\" # processing error\n  )\n}\n\n\nget_fault_regime &lt;- function(smoTransMatrob, measurement_function = \"x\" ) {\n  regime_corr &lt;- smoTransMatrob %&gt;% \n    select({{ measurement_function }}, `1`, `2`) %&gt;% \n    round(5) %&gt;% \n    cor(use = \"complete.obs\")\n  \n  which.max(regime_corr[1, 2:3]) \n}\n\n\nget_model_fails &lt;- function(path, location_id, prob_threshold, daysback, model, measurement_function, faults_only = TRUE) {\n  subset_dummy &lt;- list()\n  \n  for (location_id in location_ids) {\n    \n    models_tool &lt;- readRDS(file = str_glue(\"{path}/models/model_object_{location_id}.rds\")) \n    \n    smoTransMatrob &lt;- get_model_with_status(location_id,\n                                            models_tool,\n                                            print_error = FALSE, \n                                            model = str_glue(\"mm_{model}_{measurement_function}\"),\n                                            object = \"smoTransMatrob\") %||% next\n    fault_regime &lt;- get_model_with_status(location_id,\n                                          models_tool,\n                                          print_error = FALSE, \n                                          model = str_glue(\"mm_{model}_{measurement_function}\"),\n                                          object = \"fault_regime\") %||% next\n    \n    smoTransMatrob &lt;- smoTransMatrob %&gt;% \n      mutate(tool_name = location_id,\n             fault_probability =!!as.symbol(fault_regime), \n             fault_probability = round(fault_probability, 5)) %&gt;% \n      filter(recipe_step_start &gt; Sys.Date() - daysback)\n    \n    if (faults_only) {\n      smoTransMatrob &lt;- smoTransMatrob %&gt;% filter(fault_probability &gt;= {{ prob_threshold }})  \n    }\n    \n    subset_dummy[[location_id]] &lt;- smoTransMatrob %&gt;% \n      select(tool_name, id, {{ measurement_function }}, recipe_step_start, fault_probability)\n    \n  }\n  \n  do.call(rbind, subset_dummy) %&gt;% remove_rownames() \n}\n\n\nretrieve_model_objects &lt;- function(path, location_id, model, measurement_function) {\n  \n  models_tool &lt;- readRDS(file = str_glue(\"{path}/models/model_object_{location_id}.rds\")) \n  \n  smoTransMatrob &lt;- get_model_with_status(location_id,\n                                          models_tool,\n                                          print_error = FALSE, \n                                          model = str_glue(\"mm_{model}_{measurement_function}\"), \n                                          object = \"smoTransMatrob\")\n  smoTransMat &lt;- get_model_with_status(location_id,\n                                       models_tool, \n                                       print_error = FALSE, \n                                       model = str_glue(\"mm_{model}_{measurement_function}\"),\n                                       object = \"smoTransMat\")\n  fault_regime &lt;- get_model_with_status(location_id,\n                                        models_tool,\n                                        print_error = FALSE, \n                                        model = str_glue(\"mm_{model}_{measurement_function}\"),\n                                        object = \"fault_regime\")\n  k &lt;- get_model_with_status(location_id,\n                             models_tool,\n                             print_error = FALSE, \n                             model = str_glue(\"mm_{model}_{measurement_function}\"),\n                             object = \"k\")\n  \n  list(smoTransMatrob = smoTransMatrob,\n       smoTransMat = smoTransMat, \n       k = k, \n       fault_regime = fault_regime)\n}\n\n\ncalculate_transition_matrix &lt;- function(path, location_id, model, measurement_function, t_steps = 1L) {\n  model_objects &lt;- retrieve_model_objects(path, location_id, model, measurement_function)\n  \n  smoTransMatrob &lt;- model_objects$smoTransMatrob %&gt;% select(`1`, `2`) \n  smoTransMat &lt;- model_objects$smoTransMat\n  k &lt;- model_objects$k\n  fault_regime &lt;- model_objects$fault_regime\n  \n  gamma_t_s &lt;- matrix(apply(matrix(unlist(smoTransMat),nrow = k*k),1,sum)/rep(apply(smoTransMatrob[-1,],2,sum),rep(k,k)),ncol = k)\n  dimnames(gamma_t_s) &lt;- switch(fault_regime, \"1\" = rep(list(c(\"Fault\", \"Stable\")),2), \"2\" = rep(list(c(\"Stable\", \"Fault\")),2))\n  \n  if (t_steps &lt;= 2) return(gamma_t_s)\n  \n  gamma_t &lt;- matrix(apply(matrix(unlist(smoTransMat[1:t_steps]),nrow = k*k),1,sum)/rep(apply(head(smoTransMatrob[-1,], t_steps),2,sum),rep(k,k)),ncol = k)\n  \n  gamma_s &lt;- gamma_t_s %*% MASS::ginv(gamma_t)\n  gamma_s &lt;- abs(kronecker(gamma_s, k-1)) # This should hold true for MP invertibility\n  gamma_s &lt;- t(t(gamma_s) / apply(gamma_s, 2, sum))\n  dimnames(gamma_s) &lt;- switch(fault_regime, \"1\" = rep(list(c(\"Fault\", \"Stable\")),2), \"2\" = rep(list(c(\"Stable\", \"Fault\")),2))\n  \n  .check_topological_mapping &lt;- function(gamma_s) {\n    evec &lt;- eigen(gamma_s)$vectors\n    t(evec[, 1]) %*% evec[, 2] &lt;= abs(evec[, 1]) %*% abs(evec[, 2])\n  }\n  \n  .check_statdist &lt;- function(gamma_x) {\n    m &lt;- dim(gamma_x)[1]\n    stat_dist &lt;- matrix(1, 1, m) %*% solve(diag(1, m) - gamma_x + matrix(1, m, m))\n    \n    all.equal(eigen(gamma_x)$values, as.vector(stat_dist)) &lt; sqrt(.Machine$double.eps)\n  }\n  \n  if (!.check_topological_mapping(gamma_s) | .check_statdist(gamma_s)) return(gamma_t_s)\n  \n  gamma_s\n}\n\n\nfilter_fault_freq &lt;- function(tbl, number_of_fails) {\n  tbl %&gt;%   \n    mutate(number_of_fails = n()) %&gt;% \n    filter(number_of_fails &gt;=!!number_of_fails) \n}\n\nfilter_fault_freq_group &lt;- function(tbl, groups = c(\"fac\", \"tool_name\"), number_of_fails) {\n  tbl %&gt;%\n    group_by(across(all_of(groups))) %&gt;% \n    filter_fault_freq(number_of_fails) %&gt;%\n    distinct(across(all_of(groups)))\n}"
  },
  {
    "objectID": "model_arm_brkt.html#hilbert-huang-transform",
    "href": "model_arm_brkt.html#hilbert-huang-transform",
    "title": "4  Arm Bracket Fault Detection",
    "section": "4.2 Hilbert Huang Transform",
    "text": "4.2 Hilbert Huang Transform\n\n\nimf_ener &lt;- function(tbl, meas_fn = \"x\") {\n  sig &lt;- tbl %&gt;% pull({{ meas_fn }})\n  tt &lt;- tbl %&gt;% pull(new_sensor_dt)\n  \n  inputimfs &lt;-  Sig2IMF(sig, tt, max.imf = 3)$imf # note max IMF \n  n_cols &lt;- ncol(inputimfs)\n  n_rows &lt;- nrow(inputimfs)\n  if (is.null(n_cols)) return(tibble())\n  # mse_hilbert = sum(inputimfs[,1]^2)/n_rows\n  # ek = NULL\n  # for (i in 1:n_cols) ek &lt;- c(ek, mse_hilbert*2.01^(-i)/0.719) # https://link.springer.com/chapter/10.1007/978-3-030-89010-0_8\n  #\n  \n  # sample_ek = NULL\n  # for (i in 1:n_cols) sample_ek &lt;- c(sample_ek, sum(inputimfs[,i]^2)/n_rows)\n  \n  sample_ek &lt;- apply(inputimfs, 2, function(x){sum(x^2)/n_rows})\n  \n  tibble(n = 1:n_cols \n         # \"ek\" = ek\n  ) %&gt;% \n    mutate(\n      log_eek = log(sample_ek)/log(2)\n    ) %&gt;% \n    return()\n}"
  },
  {
    "objectID": "model_arm_brkt.html#fit-hmm",
    "href": "model_arm_brkt.html#fit-hmm",
    "title": "4  Arm Bracket Fault Detection",
    "section": "4.3 Fit HMM",
    "text": "4.3 Fit HMM\n\n\nget_mm_results &lt;- function(tf_loc_id, meas_fn) {\n  .create_objects_for_model &lt;- function(tf_loc_id, meas_fn) {\n    tf_loc_id &lt;- tf_loc_id %&gt;%\n      unnest(gi) %&gt;% \n      ungroup()\n    \n    tf_loc_id &lt;- tf_loc_id %&gt;% \n      unnest(str_glue(\"ie_{meas_fn}\")) %&gt;% \n      select(id, rs_start, n, log_eek, {{ meas_fn }}) %&gt;%\n      filter(n() &gt;= 2) %&gt;% \n      pivot_wider(values_from = log_eek, names_from = n) %&gt;%\n      drop_na(`1`, `2`)\n      \n      fml = str_glue(\"{meas_fn} ~ `2`\") %&gt;% formula()\n      \n      list(tf_loc_id = tf_loc_id, fml = fml)\n  } \n  \n  .create_mm_model &lt;- function(model_obj) {\n    n &lt;- labels(terms(model_obj$fml)) %&gt;% length() \n    \n    ms_ols_model &lt;- lm(formula = model_obj$fml,\n                       data  = model_obj$tf_loc_id) \n    \n    ms_model &lt;- msmFit(ms_ols_model,\n                       k = 2,\n                       p = 0,\n                       sw = rep(TRUE, n + 2), \n                       control = list(trace = FALSE, parallelization = TRUE))\n  }\n  \n  .process_mm_model &lt;- function(model_obj, ms_model, meas_fn) {\n    smoTransMatrob &lt;- model_obj$tf_loc_id %&gt;%  \n      select(id, rs_start, {{ meas_fn }}) %&gt;% add_row(id = NA,  .before = 1) %&gt;%\n      cbind(. ,ms_model@Fit@smoProb)\n    \n    fault_regime &lt;- get_fault_regime(smoTransMatrob, meas_fn)\n    \n    list(smoTransMatrob = smoTransMatrob,\n         smoTransMat = ms_model@Fit@smoTransMat, \n         k = ms_model@k, \n         fault_regime = fault_regime)\n  }\n  \n  model_obj &lt;- .create_objects_for_model(tf_loc_id, meas_fn)\n  ms_model &lt;- .create_mm_model(model_obj)\n  \n  .process_mm_model(model_obj, ms_model, meas_fn)\n}\n\n\nget_model_status &lt;- function(loc_id, \n                                  model_code,\n                                  print_error = TRUE,\n                                  model = \"mm_arm_brkt\",\n                                  object = \"smoTransMatrob\") {\n  \n  .print_err &lt;- function(message = \"Error\", print_error = TRUE){\n    if (print_error) print(str_glue(\"{message} in {loc_id}\")) \n    return(NULL) \n  }\n  \n  models_tool %&gt;%\n    pull({{ model }}) %&gt;% \n    pluck(1, object) %||% .print_err(print_error = print_error)\n}\n\n\nmodel_status_defs &lt;- function(type) {\n  switch(type,\n         \"named list\" = NA, # success\n         \"list\" = NA, # missing in configuration\n         \"lgl\" = \"Error\" # processing error\n  )\n}\n\n\nget_fault_regime &lt;- function(smoTransMatrob, meas_fn = \"x\" ) {\n  regime_corr &lt;- smoTransMatrob %&gt;% \n    select({{ meas_fn }}, `1`, `2`) %&gt;% \n    round(5) %&gt;% \n    cor(use = \"complete.obs\")\n  \n  which.max(regime_corr[1, 2:3]) \n}\n\n\nget_model_fails &lt;- function(path, loc_id, prob_thres, daysback, model, meas_fn, faults_only = TRUE) {\n  subset_dummy &lt;- list()\n  \n  for (loc_id in loc_ids) {\n    \n    models_tool &lt;- readRDS(file = str_glue(\"{path}/models/model_object_{loc_id}.rds\")) \n    \n    smoTransMatrob &lt;- get_model_status(loc_id,\n                                            models_tool,\n                                            print_error = FALSE, \n                                            model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                            object = \"smoTransMatrob\") %||% next\n    fault_regime &lt;- get_model_status(loc_id,\n                                          models_tool,\n                                          print_error = FALSE, \n                                          model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                          object = \"fault_regime\") %||% next\n    \n    smoTransMatrob &lt;- smoTransMatrob %&gt;% \n      mutate(tool_name = loc_id,\n             fault_prob =!!as.symbol(fault_regime), \n             fault_prob = round(fault_prob, 5)) %&gt;% \n      filter(rs_start &gt; Sys.Date() - daysback)\n    \n    if (faults_only) {\n      smoTransMatrob &lt;- smoTransMatrob %&gt;% filter(fault_prob &gt;= {{ prob_thres }})  \n    }\n    \n    subset_dummy[[loc_id]] &lt;- smoTransMatrob %&gt;% \n      select(tool_name, id, {{ meas_fn }}, rs_start, fault_prob)\n    \n  }\n  \n  do.call(rbind, subset_dummy) %&gt;% remove_rownames() \n}"
  },
  {
    "objectID": "model_arm_brkt.html#evaluate-fit",
    "href": "model_arm_brkt.html#evaluate-fit",
    "title": "4  Arm Bracket Fault Detection",
    "section": "4.4 Evaluate Fit",
    "text": "4.4 Evaluate Fit\n\n\nretrieve_model_obj &lt;- function(path, loc_id, model, meas_fn) {\n  \n  models_tool &lt;- readRDS(file = str_glue(\"{path}/models/model_object_{loc_id}.rds\")) \n  \n  smoTransMatrob &lt;- get_model_status(loc_id,\n                                          models_tool,\n                                          print_error = FALSE, \n                                          model = str_glue(\"mm_{model}_{meas_fn}\"), \n                                          object = \"smoTransMatrob\")\n  smoTransMat &lt;- get_model_status(loc_id,\n                                       models_tool, \n                                       print_error = FALSE, \n                                       model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                       object = \"smoTransMat\")\n  fault_regime &lt;- get_model_status(loc_id,\n                                        models_tool,\n                                        print_error = FALSE, \n                                        model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                        object = \"fault_regime\")\n  k &lt;- get_model_status(loc_id,\n                             models_tool,\n                             print_error = FALSE, \n                             model = str_glue(\"mm_{model}_{meas_fn}\"),\n                             object = \"k\")\n  \n  list(smoTransMatrob = smoTransMatrob,\n       smoTransMat = smoTransMat, \n       k = k, \n       fault_regime = fault_regime)\n}\n\n\nfilter_fault_freq &lt;- function(tbl, number_of_fails) {\n  tbl %&gt;%   \n    mutate(number_of_fails = n()) %&gt;% \n    filter(number_of_fails &gt;=!!number_of_fails) \n}\n\nfilter_fault_freq_group &lt;- function(tbl, groups = c(\"fac\", \"tool_name\"), number_of_fails) {\n  tbl %&gt;%\n    group_by(across(all_of(groups))) %&gt;% \n    filter_fault_freq(number_of_fails) %&gt;%\n    distinct(across(all_of(groups)))\n}"
  },
  {
    "objectID": "model_arm_brkt.html#chapman-kolmogorov",
    "href": "model_arm_brkt.html#chapman-kolmogorov",
    "title": "4  Arm Bracket Fault Detection",
    "section": "4.5 Chapman-Kolmogorov",
    "text": "4.5 Chapman-Kolmogorov\n\n\ncalc_trans_mat &lt;- function(path, loc_id, model, meas_fn, t_steps = 1L) {\n  model_obj &lt;- retrieve_model_obj(path, loc_id, model, meas_fn)\n  \n  smoTransMatrob &lt;- model_obj$smoTransMatrob %&gt;% select(`1`, `2`) \n  smoTransMat &lt;- model_obj$smoTransMat\n  k &lt;- model_obj$k\n  fault_regime &lt;- model_obj$fault_regime\n  \n  gamma_t_s &lt;- matrix(apply(matrix(unlist(smoTransMat),nrow = k*k),1,sum)/rep(apply(smoTransMatrob[-1,],2,sum),rep(k,k)),ncol = k)\n  dimnames(gamma_t_s) &lt;- switch(fault_regime, \"1\" = rep(list(c(\"Fault\", \"Stable\")),2), \"2\" = rep(list(c(\"Stable\", \"Fault\")),2))\n  \n  if (t_steps &lt;= 2) return(gamma_t_s)\n  \n  gamma_t &lt;- matrix(apply(matrix(unlist(smoTransMat[1:t_steps]),nrow = k*k),1,sum)/rep(apply(head(smoTransMatrob[-1,], t_steps),2,sum),rep(k,k)),ncol = k)\n  \n  gamma_s &lt;- gamma_t_s %*% MASS::ginv(gamma_t)\n  gamma_s &lt;- abs(kronecker(gamma_s, k-1)) # This should hold true for MP invertibility\n  gamma_s &lt;- t(t(gamma_s) / apply(gamma_s, 2, sum))\n  dimnames(gamma_s) &lt;- switch(fault_regime, \"1\" = rep(list(c(\"Fault\", \"Stable\")),2), \"2\" = rep(list(c(\"Stable\", \"Fault\")),2))\n  \n  .check_topmap &lt;- function(gamma_s) {\n    evec &lt;- eigen(gamma_s)$vectors\n    t(evec[, 1]) %*% evec[, 2] &lt;= abs(evec[, 1]) %*% abs(evec[, 2])\n  }\n  \n  .check_statdist &lt;- function(gamma_x) {\n    m &lt;- dim(gamma_x)[1]\n    stat_dist &lt;- matrix(1, 1, m) %*% solve(diag(1, m) - gamma_x + matrix(1, m, m))\n    \n    all.equal(eigen(gamma_x)$values, as.vector(stat_dist)) &lt; sqrt(.Machine$double.eps)\n  }\n  \n  if (!.check_topmap(gamma_s) | .check_statdist(gamma_s)) return(gamma_t_s)\n  \n  gamma_s\n}"
  },
  {
    "objectID": "bom.html",
    "href": "bom.html",
    "title": "1  Bill of Materials",
    "section": "",
    "text": "Each installation has its own BOM structure report.\nColumn definitions:\n\nLv: The hardware level, which can expand to multiple monitoring systems if needed.\nComponent: Serial number to be scanned if needed.\nSeq: The operation sequence from installation onward.\nDescription: Description of the part or component.\nQuantity per: Number of parts needed for functionality.\nFix: Repairability of parts.\nOn-date: Used to track stable parts. Default to “Prepared” date on top.\nOff-date: Used to track depreciated parts. NULL if stable.\nRev: Revision to track prints and schematics.\nUnit Cost: Cost at the time of document.\nVendor: Purchase location.\nVendor PN: Vendor part number.\n\n\nfile_list &lt;- list.files(\"../BOM/\", pattern = \"BOM STRUCTURE REPORT – ALL LEVELS\", full.names = TRUE)\n\nbom_data &lt;- data.frame()\n\nfor (filename in file_list) {\n  location_id &lt;- stringr::str_extract(filename, \"[A-Z]\\\\d{2}\\\\.\\\\d{2}(?=\\\\.xlsx$)\")\n  \n  data &lt;- read_xlsx(filename, skip = 6) |&gt;\n    select(-matches(\"^\\\\.\\\\.\")) |&gt; \n    mutate(location_id = location_id) \n  \n  bom_data &lt;- bind_rows(bom_data, data)\n}\n\nbom_data &lt;- bom_data |&gt; relocate(location_id) \n\nbom_data |&gt; filter(location_id == \"A00.01\")\n\n#&gt;    location_id Lv Component    Seq                         Description Quantity Fix\n#&gt; 1       A00.01 01   GD-0001 000001                 AD335 Accelerometer        1   N\n#&gt; 2       A00.01 01   GD-0003 000001          Arduino Uno WiFi R3, Board        1   N\n#&gt; 3       A00.01 01   GD-0004 000002            Cable, USB- Printer 1 ft        1   N\n#&gt; 4       A00.01 01   GD-0005 000001        Breadboard Jumper M-F ribbon        1   Y\n#&gt; 5       A00.01 02   GD-0006 000001                Cable, USB M-F 10 ft        1   N\n#&gt; 6       A00.01 01   GD-0007 000002               Extension cord, 15 ft        1   N\n#&gt; 7       A00.01 01   GD-0008 000001 Arduino Uno WiFi R3, Case, 3D print        1   Y\n#&gt; 8       A00.01 01   GD-0009 000001                    ADXL Mount, 2pcs        1   Y\n#&gt; 9       A00.01 01   GD-0010 000002                     Dell Wyse, 3040        1   Y\n#&gt; 10      A00.01 01   GD-0011 000002                  500GB M.2. Crucial        1   N\n#&gt; 11      A00.01 01   GD-0012 000001      SCREW, M2 x  4.8 mm LG, BLK OX        2   N\n#&gt; 12      A00.01 01   GD-0013 000001       SCREW, M3 x  20 mm LG, BLK OX        4   N\n#&gt;    On-date Off-date Rev Unit Cost   Vendor    Vendor PN\n#&gt; 1       NA       NA   A     14.95 adafruit 1528-1120-ND\n#&gt; 2       NA       NA   A     27.60  Digikey 1050-1024-ND\n#&gt; 3       NA       NA   A      4.99   Amazon   B08LDRMFCB\n#&gt; 4       NA       NA   A      3.95  Digikey 1528-1162-ND\n#&gt; 5       NA       NA   A      8.59   Amazon   B08FJ8Z4TJ\n#&gt; 6       NA       NA   A      7.95   Amazon   B000KKJUHE\n#&gt; 7       NA       NA   A      &lt;NA&gt;     &lt;NA&gt;         &lt;NA&gt;\n#&gt; 8       NA       NA   A      &lt;NA&gt;     &lt;NA&gt;         &lt;NA&gt;\n#&gt; 9       NA       NA   A     35.23     ebay         &lt;NA&gt;\n#&gt; 10      NA       NA   A     21.99   Amazon  CT500P3SSD8\n#&gt; 11      NA       NA   A      &lt;NA&gt;     ebay         &lt;NA&gt;\n#&gt; 12      NA       NA   A      &lt;NA&gt;     ebay         &lt;NA&gt;\n\n\nThe total cost per installation:\n\nbom_data &lt;- bom_data |&gt; \n  clean_names() |&gt; \n  mutate(unit_cost = parse_number(unit_cost))\n\nbom_data |&gt;\n  group_by(location_id) |&gt;\n  summarize(total_cost = sum(unit_cost, na.rm = T))\n\n#&gt; # A tibble: 3 × 2\n#&gt;   location_id total_cost\n#&gt;   &lt;chr&gt;            &lt;dbl&gt;\n#&gt; 1 A00.01            125.\n#&gt; 2 B00.01            125.\n#&gt; 3 C00.01            125.\n\n\nWe can also plot the parts installed.\n\nbom_data |&gt; \n  group_by(location_id, component, description) |&gt; \n  count() |&gt; \n  ggplot(aes(component, n, fill = location_id)) +\n  geom_col() +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))\n\n\n\n\nIf there are any one offs, you could filter through the original table using the serial number to track parts."
  },
  {
    "objectID": "datacollection.html#get-data",
    "href": "datacollection.html#get-data",
    "title": "5  Query Stored Data",
    "section": "5.3 Get Data",
    "text": "5.3 Get Data\n\ntbl &lt;- DBI::dbGetQuery(\n  conn = con,\n  \n  \"WITH joined_tbl AS (\n    SELECT\n      gd_config_hw_tbl.*,\n      meas_date,\n      meas_seq,\n      status,\n      gd_meas_tbl.model AS model,\n      prob,\n      model_version,\n      version_from,\n      version_to\n    FROM gd_config_hw_tbl\n    INNER JOIN gd_meas_tbl\n      ON (gd_config_hw_tbl.location_id = gd_meas_tbl.location_id)\n    INNER JOIN gd_config_models_tbl\n      ON (\n        gd_config_hw_tbl.location_id = gd_config_models_tbl.location_id AND\n        gd_meas_tbl.model = gd_config_models_tbl.model\n         )\n    )\n  \n  SELECT\n    state,\n    city_code,\n    location_id,\n    model,\n    model_version,\n    meas_date,\n    MAX(prob) AS prob_max\n  FROM joined_tbl\n  WHERE (meas_date &gt;= version_from AND ((version_to IS NULL) OR meas_date &lt;= version_to))\n  GROUP BY state, city_code, location_id, model, model_version, meas_date;\"\n)\n\ntbl |&gt; head(10)\n\n#&gt;    state city_code location_id    model model_version  meas_date  prob_max\n#&gt; 1     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-12 0.0008547\n#&gt; 2     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-13 0.0014096\n#&gt; 3     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-14 0.0009876\n#&gt; 4     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-15 0.0023421\n#&gt; 5     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-15 0.0023421\n#&gt; 6     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-16 0.0069242\n#&gt; 7     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-17 0.0062839\n#&gt; 8     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-18 0.0352436\n#&gt; 9     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-19 0.0210955\n#&gt; 10    MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-20 0.0015077"
  },
  {
    "objectID": "bom.html#column-definitions",
    "href": "bom.html#column-definitions",
    "title": "1  Bill of Materials",
    "section": "1.1 Column Definitions",
    "text": "1.1 Column Definitions\n\nLv: The hardware level, which can expand to multiple monitoring systems if needed.\nComponent: Serial number to be scanned if needed.\nSeq: The operation sequence from installation onward.\nDescription: Description of the part or component.\nQuantity per: Number of parts needed for functionality.\nFix: Repairability of parts.\nOn-date: To track stable parts. Default to “Prepared” date on top.\nOff-date: To track depreciated parts. NULL if stable.\nRev: Revision to track prints and schematics.\nUnit Cost: Cost at the time of document.\nVendor: Vendor information of location.\nVendor PN: Vendor part number.\n\n\nfile_list &lt;- list.files(\"../BOM/\", pattern = \"BOM STRUCTURE REPORT – ALL LEVELS\", full.names = TRUE)\n\nbom_data &lt;- data.frame()\n\nfor (filename in file_list) {\n  location_id &lt;- stringr::str_extract(filename, \"[A-Z]\\\\d{2}\\\\.\\\\d{2}(?=\\\\.xlsx$)\")\n  \n  data &lt;- read_xlsx(filename, skip = 6) |&gt;\n    select(-matches(\"^\\\\.\\\\.\")) |&gt; \n    mutate(location_id = location_id) \n  \n  bom_data &lt;- bind_rows(bom_data, data)\n}\n\nbom_data &lt;- bom_data |&gt; relocate(location_id) \n\nbom_data |&gt; filter(location_id == \"A00.01\") |&gt; DT::datatable()"
  },
  {
    "objectID": "bom.html#get-total-cost-per-installation",
    "href": "bom.html#get-total-cost-per-installation",
    "title": "1  Material Tracking",
    "section": "1.3 Get Total Cost per Installation",
    "text": "1.3 Get Total Cost per Installation\n\nbom_data &lt;- bom_data |&gt; \n  clean_names() |&gt; \n  mutate(unit_cost = parse_number(unit_cost))\n\nbom_data |&gt;\n  group_by(location_id) |&gt;\n  summarize(total_cost = sum(unit_cost, na.rm = T))\n\n#&gt; # A tibble: 3 × 2\n#&gt;   location_id total_cost\n#&gt;   &lt;chr&gt;            &lt;dbl&gt;\n#&gt; 1 A00.01            125.\n#&gt; 2 B00.01            125.\n#&gt; 3 C00.01            125."
  },
  {
    "objectID": "bom.html#plot-installed-parts-by-serial-number",
    "href": "bom.html#plot-installed-parts-by-serial-number",
    "title": "1  Bill of Materials",
    "section": "1.3 Plot installed parts by serial number:",
    "text": "1.3 Plot installed parts by serial number:\nIf there are any one offs, one could filter through the original table using the serial number to track parts.\n\nbom_data |&gt; \n  group_by(location_id, component, description) |&gt; \n  count() |&gt; \n  ggplot(aes(component, n, fill = location_id)) +\n  geom_col() +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))"
  },
  {
    "objectID": "bom.html#bom-structure-report",
    "href": "bom.html#bom-structure-report",
    "title": "1  Bill of Materials",
    "section": "1.2 BOM Structure Report",
    "text": "1.2 BOM Structure Report\n\nEach device has its own BOM structure report. When a QR reader is used to scan a device, this item will be listed on the landing page.\n\nfile_list &lt;- list.files(\"../BOM/\", pattern = \"BOM STRUCTURE REPORT – ALL LEVELS\", full.names = TRUE)\n\nbom_data &lt;- data.frame()\n\nfor (filename in file_list) {\n  location_id &lt;- stringr::str_extract(filename, \"[A-Z]\\\\d{2}\\\\.\\\\d{2}(?=\\\\.xlsx$)\")\n  \n  data &lt;- read_xlsx(filename, skip = 6) |&gt;\n    select(-matches(\"^\\\\.\\\\.\")) |&gt; \n    mutate(location_id = location_id) \n  \n  bom_data &lt;- bind_rows(bom_data, data)\n}\n\nbom_data &lt;- bom_data |&gt; relocate(location_id) \n\nbom_data |&gt; filter(location_id == \"A00.01\") |&gt; DT::datatable()\n\n\n\n\n\n\nDefinitions:\n\nLv: The hardware level, which can expand to multiple monitoring systems if needed.\nComponent: Serial number to be scanned if needed.\nSeq: The operation sequence from installation onward.\nDescription: Description of the part or component.\nQuantity per: Number of parts needed for functionality.\nFix: Repairability of parts.\nOn-date: To track stable parts. Default to “Prepared” date on top.\nOff-date: To track depreciated parts. NULL if stable.\nRev: Revision to track prints and schematics.\nUnit Cost: Cost at the time of document.\nVendor: Vendor information of location.\nVendor PN: Vendor part number."
  },
  {
    "objectID": "datacollection.html#example-workflow",
    "href": "datacollection.html#example-workflow",
    "title": "5  Query Stored Data",
    "section": "5.1 Example Workflow",
    "text": "5.1 Example Workflow\n\n5.1.1 Make a Connection\n\ncon &lt;- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"gd_phm_status\",\n  host = Sys.getenv(\"gd_db_host\"),\n  port = 5432,\n  user = Sys.getenv(\"gd_db_user\"),\n  password = Sys.getenv(\"gd_db_pw\")\n)\n\n\n\n5.1.2 Get Relevant Table Names\n\ntbl &lt;- DBI::dbGetQuery(\n  conn = con,\n  \"SELECT table_name\n  FROM information_schema.tables\n  WHERE table_name like '%gd%'\n\"\n)\n\ntbl |&gt; pull(table_name) |&gt; cat(sep = \", \")\n\n#&gt; gd_meas_tbl, gd_config_hw_tbl, gd_config_models_tbl\n\n\n\n\n5.1.3 Query Data\n\ntbl &lt;- DBI::dbGetQuery(\n  conn = con,\n  \n  \"WITH joined_tbl AS (\n    SELECT\n      gd_config_hw_tbl.*,\n      meas_date,\n      meas_seq,\n      status,\n      gd_meas_tbl.model AS model,\n      prob,\n      model_version,\n      version_from,\n      version_to\n    FROM gd_config_hw_tbl\n    INNER JOIN gd_meas_tbl\n      ON (gd_config_hw_tbl.location_id = gd_meas_tbl.location_id)\n    INNER JOIN gd_config_models_tbl\n      ON (\n        gd_config_hw_tbl.location_id = gd_config_models_tbl.location_id AND\n        gd_meas_tbl.model = gd_config_models_tbl.model\n         )\n    )\n  \n  SELECT\n    state,\n    city_code,\n    location_id,\n    model,\n    model_version,\n    meas_date,\n    MAX(prob) AS prob_max\n  FROM joined_tbl\n  WHERE (meas_date &gt;= version_from AND ((version_to IS NULL) OR meas_date &lt;= version_to))\n  GROUP BY state, city_code, location_id, model, model_version, meas_date;\"\n)\n\ntbl |&gt; head(10)\n\n#&gt;    state city_code location_id    model model_version  meas_date  prob_max\n#&gt; 1     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-12 0.0008547\n#&gt; 2     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-13 0.0014096\n#&gt; 3     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-14 0.0009876\n#&gt; 4     MN       AAA      A00.01 arm_brkt    2023.03.12 2023-03-15 0.0023421\n#&gt; 5     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-15 0.0023421\n#&gt; 6     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-16 0.0069242\n#&gt; 7     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-17 0.0062839\n#&gt; 8     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-18 0.0352436\n#&gt; 9     MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-19 0.0210955\n#&gt; 10    MN       AAA      A00.01 arm_brkt    2023.03.15 2023-03-20 0.0015077\n\n\n\n\n5.1.4 Plot Data\n\ntbl |&gt; \n  filter(meas_date &lt; as.Date(\"2023-06-11\")) |&gt; # to reproduce the landing page\n  mutate(model = ifelse(model == \"arm_brkt\", \"Arm Bracket Fault\", model)) |&gt; \n  ggplot(aes(meas_date, prob_max, col = model_version)) +\n  geom_point() +\n  facet_grid(location_id~ model, scales = \"free\") +\n  scale_x_date(date_breaks = \"2 weeks\") +\n  labs(\n    title = \"Daily Maximum Fault Probability for Each IoT Device Monitored Against Model Version\", \n    x = \"Date\", \n    y = \"Fault Probability\",\n    col = \"Model Version\"\n      )\n\n\n\n\n\n\n5.1.5 Important!\nPlease close the connection after you are done.\n\ndbDisconnect(con)"
  },
  {
    "objectID": "preprocessing.html#signal",
    "href": "preprocessing.html#signal",
    "title": "3  Preprocessing Methods",
    "section": "3.1 Signal",
    "text": "3.1 Signal\nShown below is a signal for one complete cycle. Note that the Acceleration of y axis, the axis that is pointing down, is not exactly at 1g.\n\nd &lt;- pre_proc_tbl(\"2023-06-10_garagedoor-1\") \n\nd |&gt; \n  plot_ad() +\n  labs(title = \"Accelerometer Signal (Triaxial)\")"
  },
  {
    "objectID": "preprocessing.html#median-filter",
    "href": "preprocessing.html#median-filter",
    "title": "3  Preprocessing Methods",
    "section": "3.2 Median Filter",
    "text": "3.2 Median Filter\n\nThe data has irregular spike patterns caused by the slack of the curved door arm. A simple filter is used to remove them.\n\n3.2.1 Verify Filter\nThe choice of n should be the minimum odd value that will remove added spikes from the baseline signal.\n\nset.seed(123)\nt &lt;- seq(0, 10, length.out = 1000)\n\nimp_sig &lt;- rpois(length(t), lambda = 0.1) \nimp_sig_damp &lt;- imp_sig * 0.01\nsignal &lt;- exp(0.2 * -1*exp(-t)) + imp_sig_damp\n\nmmed &lt;- function(x,n=9){runmed(x,n)} \n\nsignal_fil &lt;- mmed(signal, n = 7) \n\nd_med &lt;- tibble(\n  Original = signal,\n  Filtered = signal_fil\n) %&gt;%\n  mutate(t = seq_along(Original)) %&gt;%\n  pivot_longer(cols = c(Original, Filtered)) |&gt; \n  mutate(name = fct_relevel(name, c(\"Original\", \"Filtered\")))\n\nd_med |&gt; ggplot(aes(t, value)) +\n  geom_point() +\n  facet_wrap(~name) +\n  labs(title = \"Median Filter Test on a Gompertz Curve\")\n\n\n\n\n\n\n3.2.2 Filter Data\nThe choice of n should be the minimum odd value that will produce the final segmentation on the baseline signal. The baseline signal is the calibrated, initial measurement. This parameter needs to be verified during the qualification process.\n\nd &lt;- d |&gt; mutate(across(c(x, y, z), ~mmed(x = ., n = 5)))\n\nd |&gt; \n  plot_ad() +\n  labs(title = \"Filtered Signal\")\n\n\n\n\nNote that this process removes some information, and it is not the signal that is fed to the models."
  },
  {
    "objectID": "preprocessing.html#grenerate-virtual-recipe-steps",
    "href": "preprocessing.html#grenerate-virtual-recipe-steps",
    "title": "3  Preprocessing Methods",
    "section": "3.3 Grenerate Virtual Recipe Steps",
    "text": "3.3 Grenerate Virtual Recipe Steps\n\nThe following is an automated procedure that cleans and segments the signal into idle, turn, and impulse responses.\n\n3.3.1 Extract Turn Response\n\nThe first step is to smooth the signal, and a machine learning method is used to isolate the accelerometer response around a turn.\n\nd &lt;- d |&gt; \n  mutate(z_smo = loess(z ~ time, span = 0.1)$fitted, \n         y_smo = loess(y ~ time, span = 0.1)$fitted) \n\nts_data &lt;- d |&gt; pull(z_smo) |&gt; ts()\n\nd |&gt; \n  pivot_longer(c(z, z_smo, y, y_smo)) |&gt; \n  ggplot(aes(time, value)) +\n  geom_point(size = 0.5) +\n  facet_wrap(~name) +\n  labs(title = \"Smoothed Signal\")\n\n\n\n\n\nimport statsmodels.api as sm1\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pylab as plt\nfrom sklearn import linear_model, datasets\n\n# Return the t-statistic for a given parameter estimate.\ndef tValLinR(close):\n    # tValue from a linear trend\n    x = np.ones((close.shape[0], 2))\n    x[:, 1] = np.arange(close.shape[0])\n    ols = sm1.OLS(close, x).fit()\n    return ols.tvalues[1]\n\n\ndef getBinsFromTrend(molecule, close, span):\n    '''\n    Derive labels from the sign of t-value of trend line\n    output includes:\n      - t1: End time for the identified trend\n      - tVal: t-value associated with the estimated trend coefficient\n      - bin: Sign of the trend\n    The t-statistics for each tick has a different look-back window.\n\n    - idx start time in look-forward window\n    - dt1 stop time in look-forward window\n    - df1 is the look-forward window\n    - iloc ?\n    '''\n    out = pd.DataFrame(index=molecule, columns=['t1', 'tVal', 'bin', 'windowSize'])\n    hrzns = range(*span)\n    windowSize = span[1] - span[0]\n    maxWindow = span[1] - 1\n    minWindow = span[0]\n    for idx in close.index:\n        idx += maxWindow\n        if idx &gt;= len(close):\n            break\n        df_tval = pd.Series(dtype='float64')\n        iloc0 = close.index.get_loc(idx)\n        # if iloc0+max(hrzns) &gt; close.shape[0]:\n        #    continue\n        for hrzn in hrzns:\n            dt1 = close.index[iloc0 - hrzn + 1]\n            df1 = close.loc[dt1:idx]\n            df_tval.loc[dt1] = tValLinR(df1.values)  # calculates t-statistics on period\n            dt1 = df_tval.replace([-np.inf, np.inf, np.nan],\n                              0).abs().idxmax()  # get largest t-statistics calculated over span period\n\n        # print(df_tval.index[-1])\n        # print(dt1)\n        # print(abs(df_tval.values).argmax() + minWindow)\n        out.loc[idx, ['t1', 'tVal', 'bin', 'windowSize']] = df_tval.index[-1], df_tval[dt1], np.sign(df_tval[dt1]), abs(\n            df_tval.values).argmax() + minWindow  # prevent leakage\n    out['t1'] = pd.to_datetime(out['t1'])\n    out['bin'] = pd.to_numeric(out['bin'], downcast='signed')\n\n    # deal with massive t-Value outliers - they dont provide more confidence and they ruin the scatter plot\n    tValueVariance = out['tVal'].values.var()\n    tMax = 20\n    if tValueVariance &lt; tMax:\n        tMax = tValueVariance\n\n    out.loc[out['tVal'] &gt; tMax, 'tVal'] = tMax  # cutoff tValues &gt; 20\n    out.loc[out['tVal'] &lt; (-1) * tMax, 'tVal'] = (-1) * tMax  # cutoff tValues &lt; -20\n    return out.dropna(subset=['bin'])\n\n\n\nidx_range_from = 5\nidx_range_to = 10\ndf0 = pd.Series(r.ts_data)\n\nspan = [idx_range_from,idx_range_to,1] # [3,10,1] = range(3,10)\n\ndf1 = getBinsFromTrend(df0.index, df0, span) \ntValues = df1['tVal'].values\n\n\nlibrary(reticulate)\n\nd_f &lt;- py$df1 |&gt; \n  rownames_to_column(\"id\") |&gt; \n  unnest(tVal) \n\nd_fmerg &lt;- d |&gt; \n  rownames_to_column(\"id\") |&gt; \n  left_join(d_f) |&gt;\n  tidyr::fill(bin, .direction = \"downup\") |&gt; \n  mutate(id = as.numeric(id)) |&gt; \n  na.omit() |&gt; \n  mutate(run_id = consecutive_id(bin)) |&gt; \n  group_by(run_id) |&gt; \n  mutate(bin = ifelse(n() &lt; 1000, 0, bin))\n\nd_fmerg |&gt; \n  ggplot(aes(id, z, col = as.factor(bin))) +\n  geom_point(size = 0.3) +\n  labs(x = \"time (s)\", \n       y = \"Acceleration (g)\",\n       col = \"Recipe Step\")\n\n\n\n\nLegend definitions:\n\n0: Horizontal or vertical position\n-1: Turn, coming down\n1: Turn, going up\n\n\n\n3.3.2 Extract Door Idle Response\n\nThe following is a dependent mixture model to detect when the door is idle.\n\nlibrary(depmixS4)\n\nset.seed(123)\n\nhmm_model &lt;- depmixS4::depmix(data = d_fmerg, nstates = 2, y_smo~y)\nhmm_fit &lt;- fit(hmm_model)\n\n#&gt; converged at iteration 21 with logLik: 40562\n\n# hmm_fit@transition\n\n# plot(ts(posterior(hmm_fit, type = \"smoothing\")), ylab = \"probability\", frame = FALSE)"
  },
  {
    "objectID": "bom.html#plot-installed-parts",
    "href": "bom.html#plot-installed-parts",
    "title": "1  Material Tracking",
    "section": "1.4 Plot Installed Parts",
    "text": "1.4 Plot Installed Parts\nIf there are any nonconformities, one could cross check the serial numbers to track parts.\n\nbom_data |&gt; \n  group_by(location_id, component, description) |&gt; \n  count(name = \"quantity\") |&gt; \n  ggplot(aes(component, quantity, fill = location_id)) +\n  geom_col() +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))"
  },
  {
    "objectID": "calibration.html#installation",
    "href": "calibration.html#installation",
    "title": "2  Installation and Calibration",
    "section": "2.2 Installation",
    "text": "2.2 Installation\n\n2.2.1 Thin Client\n\n\n\n2.2.2 ADXL335 to Arduino\n\nThe ADXL335 is a triaxial accelerometer with three analog outputs that correspond to the orthogonal X, Y, and Z axes. The accelerometer responds to tilt, and since it is mounted in parallel to the door (reference), this measurement translates to a dynamic angle of incline.\nThe technical datasheet for ADXL335 is here.\nThe accelerometer is connected to the Arduino following the instructions available here.\n\n\n2.2.3 Preliminary Calibration\n\nThe calibration procedure is explained here. This also serves as a secondary purpose of verifying the functionality of the accelerometer.\n\n#include &lt;math.h&gt;\nconst int x_out = A0; \nconst int y_out = A1; \nconst int z_out = A2; \n\nunsigned long tms;\n\nvoid setup() {\n  Serial.begin(115200); \n}\n\nvoid loop() {\n  int x_adc_value, y_adc_value, z_adc_value; \n  \n  x_adc_value = analogRead(x_out);  \n  y_adc_value = analogRead(y_out);  \n  z_adc_value = analogRead(z_out);  \n\n//  Serial.print(\"x = \");\n//  Serial.print(x_adc_value);\n//  Serial.print(\"\\t\\t\");\n//  Serial.print(\"y = \");\n//  Serial.print(y_adc_value);\n//  Serial.print(\"\\t\\t\");\n//  Serial.print(\"z = \");\n//  Serial.print(z_adc_value);\n//  Serial.println(\"\\t\\t\");\n\n// Right hand rule is constrained\n\n  int x = map(x_adc_value, 264, 396, -100, 100);\n  float xg = (float)x/(-100.00);\n  \n  int y = map(y_adc_value, 267, 400, -100, 100);\n  float yg = (float)y/(-100.00);\n\n  int z = map(z_adc_value, 275, 410, -100, 100);\n  float zg = (float)z/(-100.00);\n\n\n// CW is positive\n\ndouble tilt_fc, tilt_tw;\n\n//  tilt_X =atan2(-yg,-zg)*57.2957795; /* yaw dof cannot be measured */ \n  tilt_fc = -1*atan2(xg,yg)*57.2957795; /* across the face of the door */\n  tilt_tw = -1*atan2(zg,yg)*57.2957795; /* towards and back */\n  \n\n  tms = millis();\n\n  Serial.print(tms); \n  Serial.print(\"\\t\");\n  Serial.print(xg);\n  Serial.print(\"\\t\");\n  Serial.print(yg);\n  Serial.print(\"\\t\");\n  Serial.print(zg);\n  Serial.print(\"\\t\");\n  Serial.print(tilt_fc);\n  Serial.print(\"\\t\");\n  Serial.print(tilt_tw);\n  Serial.print(\"\\n\");\n  \n//  delay(1000);\n\n}\n\n\n\n2.2.4 Install Adjustable Mount\nThe accelerometer mount should be installed closer to the arm bracket, the closer the better."
  },
  {
    "objectID": "calibration.html#tilt-orientation-adjustment",
    "href": "calibration.html#tilt-orientation-adjustment",
    "title": "2  Installation and Calibration",
    "section": "2.4 Tilt Orientation Adjustment",
    "text": "2.4 Tilt Orientation Adjustment\n\nThe accelerometer mount is adjustable, and the reference tilt angle (tilt_fc, above) can be adjusted by loosening the M3 screws.\nThe door moves relative to the left and right tracks, and this can cause problems to the “Track” failure model if the accelerometer is not positioned correctly. Here are three outputs for three angles, -17 deg (CCW), 0 deg, and 17 deg (CW).\n\np_1 &lt;- pre_proc_tbl(\"angle-ccw17\") |&gt; \n  plot_ad() +\n  labs(title = \"-17 deg\") +\n  geom_hline(yintercept = c(0, 1), col = \"darkred\") +\n  theme(axis.title = element_blank())\n\np_2 &lt;- pre_proc_tbl(\"2023-06-10_garagedoor-1\") |&gt; \n  plot_ad() +\n  labs(title = \"0 deg\") +\n  geom_hline(yintercept = c(0, 1), col = \"darkred\") +\n  theme(axis.title = element_blank())\n\np_3 &lt;- pre_proc_tbl(\"angle-cw17\") |&gt; \n  plot_ad() +\n  labs(title = \"+17 deg\") +\n  geom_hline(yintercept = c(0, 1), col = \"darkred\") +\n  theme(axis.title = element_blank())\n\np &lt;- p_1 /p_2/ p_3 \n\ngt &lt;- patchwork::patchworkGrob(p)\ngridExtra::grid.arrange(gt, left = \"Acceleration (g)\", bottom = \"time (s)\")\n\n\n\n\nIt is hard to see any difference between these signals other than for x. Fixing x to an initial 0g position is not optimal because the door moves relative to the track positions. There is no guarantee that the door movement is “flat” against the ground.\n\n2.4.1 Mutual Infrmation\nThe following procedure adresses this problem by to exploiting the nonlinear dependence between sensor variables, namely x-y and x-z. The solution also works well with raw data, which is an advantage.\nBelow is an example calculation for the mutual information between x and y for the signal at 0 degrees. A lower value indicates better “alignment” of the accelerometer.\n\nd &lt;- pre_proc_tbl(\"2023-06-10_garagedoor-1\") \n\n\nimport numpy as np\nimport scipy.stats as ss\nfrom sklearn.metrics import mutual_info_score\n\ndef numBins(nObs, corr=None):\n    #optimal number of bins for discretization\n    if corr is None: #univariate case\n        z = (8+324*nObs+12*(36*nObs+729*nObs**2)**.5)**(1/3.)\n        b = round(z/6.+2./(3*z)+1./3)\n    else: #bivariate case\n        b = round(2**-.5*(1+(1+24*nObs/(1.-corr**2))**.5)**.5)\n    \n    return int(b)\n\ndef mutualInfor(x,y, norm=False):\n  #mutual information\n  bXY = numBins(x.shape[0], corr = np.corrcoef(x,y)[0,1])\n  cXY = np.histogram2d(x,y, bXY)[0]\n  iXY = mutual_info_score(None, None, contingency=cXY)\n  if norm:\n    hX = ss.entropy(np.histogram(x, bins)[0]) #marginal \n    hY = ss.entropy(np.histogram(y, bins)[0]) #marginal\n    iXY /= min(hX, hY) #normalized mutual information\n    \n  return iXY\n\nx = r.d['x']\nx = np.array(x)\n\ny = r.d['y']\ny = np.array(y)\n\nbins=10 # descretize sample space\n\nnmi = mutualInfor(x,y,True)\n\nd = {\"nmi\": nmi}\n\nd\n\n#&gt; {'nmi': 0.46746092071197676}\n\n\n\n\n2.4.2 Tilt Angle Sweep\n\nTo determine the optimal angle, a sweep needs to be done at varying increments. Typically, this is done within a range of approximately ±10 degrees from zero.\n\nd_long &lt;- read_csv(\"../data/mu-i_angle_swp.csv\") %&gt;%\n  pivot_longer(cols = c(\"xy\", \"yz\", \"xz\"), names_to = \"name\", values_to = \"value\")\n\npreds &lt;- list()\nfor (name_2 in unique(d_long$name)) {\n  nd &lt;- d_long |&gt; dplyr::filter(name == name_2)\n  mars_model &lt;- earth::earth(value ~ angle, data = nd, nk = 3)\n  preds[[name_2]] &lt;- mars_model |&gt; predict()\n}\n\nangles &lt;- d_long |&gt; \n  filter(name == \"xy\") |&gt; \n  pull(angle)\n\npreds_df &lt;- data.frame(name = rep(names(preds), sapply(preds, length)),\n                 value = unlist(preds), angle =  angles)\n\nd_long |&gt; \n  ggplot(aes(angle, value, col = name)) +\n  geom_point() +\n  geom_line(data = preds_df, aes(angle, value)) +\n  scale_x_continuous(breaks = scales::pretty_breaks(n = 20)) +\n  labs(x = \"Angle (deg)\", \n       y = \"Mutual Information\" ,\n       col = \"Variables\", \n       title = \"Angle Sweep Results\")\n\n\n\n\nThe curve follows a hinge function. It is recommended to re-measure at the lowest three positions. In this instance, the sensor was positioned at a five-degree CW offset."
  },
  {
    "objectID": "calibration.html#system-configuration",
    "href": "calibration.html#system-configuration",
    "title": "2  Installation and Calibration",
    "section": "2.1 System Configuration",
    "text": "2.1 System Configuration\n\n\n\n\n\n\n\n\n\n\ngraph TB\nA(Accelerometer)--&gt;AA \n\nsubgraph Future-Replace\nAA[Arduino]--&gt;E[Thin Client]\nstyle Future-Replace fill:#f0f0f0,stroke:grey,stroke-width:2px\nend\n\nE--&gt;F[AWS RDS]\nF--&gt;FF[Decisions / Notifications]\nF--&gt;G(\"Dashboard &lt;/br&gt;(Metrics, Sensor Data,  Decisions)\")\nFF-.-&gt;G\nGD(Garage Door) -.-&gt; A\nstyle G fill:#B6E6E6\nstyle GD fill:salmon \nstyle E stroke:blue,stroke-width:3px\n\nsubgraph Thin-Client\nBB((Every &lt;/br&gt; 2 Hours))--&gt;CA[Gather Data]\nBB--&gt;CAA[Preprocess]\nCAA--&gt;CAAB{Door Activity?}\nCAAB--Yes--&gt;CBB[Run Models]\nCAAB--No--&gt;CAAC(End)\nCBB--&gt;CB[Data / Results]\nstyle BB fill:salmon \nstyle Thin-Client fill:#f0f0f0,stroke:blue,stroke-width:3px\nend"
  },
  {
    "objectID": "bom.html#qr-scanner",
    "href": "bom.html#qr-scanner",
    "title": "1  Material Tracking",
    "section": "1.1 QR Scanner",
    "text": "1.1 QR Scanner"
  },
  {
    "objectID": "bom.html#bill-of-materials-bom-structure-report",
    "href": "bom.html#bill-of-materials-bom-structure-report",
    "title": "1  Material Tracking",
    "section": "1.2 Bill of Materials (BOM) Structure Report",
    "text": "1.2 Bill of Materials (BOM) Structure Report\n\nEach device has its own BOM structure report. When a QR reader is used to scan a device, this item will be listed on the landing page.\n\nfile_list &lt;- list.files(\"../BOM/\", pattern = \"BOM STRUCTURE REPORT – ALL LEVELS\", full.names = TRUE)\n\nbom_data &lt;- data.frame()\n\nfor (filename in file_list) {\n  location_id &lt;- stringr::str_extract(filename, \"[A-Z]\\\\d{2}\\\\.\\\\d{2}(?=\\\\.xlsx$)\")\n  \n  data &lt;- read_xlsx(filename, skip = 6) |&gt;\n    select(-matches(\"^\\\\.\\\\.\")) |&gt; \n    mutate(location_id = location_id) \n  \n  bom_data &lt;- bind_rows(bom_data, data)\n}\n\nbom_data &lt;- bom_data |&gt; relocate(location_id) \n\nbom_data |&gt; filter(location_id == \"A00.01\") |&gt; DT::datatable()\n\n\n\n\n\n\nDefinitions:\n\nLv: The hardware level, which can expand to multiple monitoring systems if needed.\nComponent: Serial number to be scanned if needed.\nSeq: The operation sequence from installation onward.\nDescription: Description of the part or component.\nQuantity per: Number of parts needed for functionality.\nFix: Repairability of parts.\nOn-date: To track stable parts. Default to “Prepared” date on top.\nOff-date: To track depreciated parts. NULL if stable.\nRev: Revision to track prints and schematics.\nUnit Cost: Cost at the time of document.\nVendor: Vendor information of location.\nVendor PN: Vendor part number."
  },
  {
    "objectID": "calibration.html#adxl335-to-arduino",
    "href": "calibration.html#adxl335-to-arduino",
    "title": "2  Installation and Calibration",
    "section": "2.4 ADXL335 to Arduino",
    "text": "2.4 ADXL335 to Arduino\nThe ADXL335 is a triaxial accelerometer with three analog outputs that correspond to the orthogonal X, Y, and Z axes. The accelerometer responds to tilt, and since it is mounted in parallel to the door (reference), this measurement translates to a dynamic angle of incline.\nThe technical datasheet for ADXL335 is here.\nThe accelerometer is connected to the Arduino following the instructions available here.\n\n2.4.1 Install Adjustable Mount\nThe accelerometer mount should be installed closer to the arm bracket, the closer the better."
  },
  {
    "objectID": "calibration.html#definition-of-a-cycle",
    "href": "calibration.html#definition-of-a-cycle",
    "title": "2  Installation and Calibration",
    "section": "2.3 Definition of a Cycle",
    "text": "2.3 Definition of a Cycle\nA complete sequence of opening and closing the garage door, including the upward and downward movements, starting from the closed position to fully open and then back to the closed position.\nHere is my garage door opening and closing, showing one complete cycle:\n\nFor testing purposes, there will be an initial delay, idle on top, and ending delay, all five seconds."
  },
  {
    "objectID": "preprocessing.html#example-signal",
    "href": "preprocessing.html#example-signal",
    "title": "3  Preprocessing Methods",
    "section": "3.1 Example Signal",
    "text": "3.1 Example Signal\nShown below is a signal for a complete cycle. Note that the acceleration of the y axis (pointing down), is not at 1g. This is an acceptable condition.\n\nd &lt;- pre_proc_tbl(\"2023-06-10_garagedoor-1\") \n\nd |&gt; \n  plot_ad() +\n  labs(title = \"Accelerometer Signal (Triaxial)\")"
  },
  {
    "objectID": "maintenance_tracking.html",
    "href": "maintenance_tracking.html",
    "title": "6  Maintenance Tracking",
    "section": "",
    "text": "The current AWS tables take too much time to analyze and edit."
  },
  {
    "objectID": "model_arm_brkt.html#hilbert-spectrum",
    "href": "model_arm_brkt.html#hilbert-spectrum",
    "title": "4  Arm Bracket Fault Detection",
    "section": "4.1 Hilbert Spectrum",
    "text": "4.1 Hilbert Spectrum\n\nlibrary(dissthispkgr)"
  },
  {
    "objectID": "fault_diagnostics.html#hilbert-spectrum",
    "href": "fault_diagnostics.html#hilbert-spectrum",
    "title": "4  Fault Diagnostics",
    "section": "4.1 Hilbert Spectrum",
    "text": "4.1 Hilbert Spectrum\n\nlibrary(dissthispkgr)"
  },
  {
    "objectID": "fault_diagnostics.html#hilbert-huang-transform",
    "href": "fault_diagnostics.html#hilbert-huang-transform",
    "title": "4  Fault Diagnostics",
    "section": "4.2 Hilbert Huang Transform",
    "text": "4.2 Hilbert Huang Transform\n\n\nimf_ener &lt;- function(tbl, meas_fn = \"x\") {\n  sig &lt;- tbl %&gt;% pull({{ meas_fn }})\n  tt &lt;- tbl %&gt;% pull(new_sensor_dt)\n  \n  inputimfs &lt;-  Sig2IMF(sig, tt, max.imf = 3)$imf # note max IMF \n  n_cols &lt;- ncol(inputimfs)\n  n_rows &lt;- nrow(inputimfs)\n  if (is.null(n_cols)) return(tibble())\n  # mse_hilbert = sum(inputimfs[,1]^2)/n_rows\n  # ek = NULL\n  # for (i in 1:n_cols) ek &lt;- c(ek, mse_hilbert*2.01^(-i)/0.719) # https://link.springer.com/chapter/10.1007/978-3-030-89010-0_8\n  #\n  \n  # sample_ek = NULL\n  # for (i in 1:n_cols) sample_ek &lt;- c(sample_ek, sum(inputimfs[,i]^2)/n_rows)\n  \n  sample_ek &lt;- apply(inputimfs, 2, function(x){sum(x^2)/n_rows})\n  \n  tibble(n = 1:n_cols \n         # \"ek\" = ek\n  ) %&gt;% \n    mutate(\n      log_eek = log(sample_ek)/log(2)\n    ) %&gt;% \n    return()\n}"
  },
  {
    "objectID": "fault_diagnostics.html#fit-hmm",
    "href": "fault_diagnostics.html#fit-hmm",
    "title": "4  Fault Diagnostics",
    "section": "4.4 Fit HMM",
    "text": "4.4 Fit HMM\n\n\nget_mm_results &lt;- function(tf_loc_id, meas_fn) {\n  .create_objects_for_model &lt;- function(tf_loc_id, meas_fn) {\n    tf_loc_id &lt;- tf_loc_id %&gt;%\n      unnest(gi) %&gt;% \n      ungroup()\n    \n    tf_loc_id &lt;- tf_loc_id %&gt;% \n      unnest(str_glue(\"ie_{meas_fn}\")) %&gt;% \n      select(id, rs_start, n, log_eek, {{ meas_fn }}) %&gt;%\n      filter(n() &gt;= 2) %&gt;% \n      pivot_wider(values_from = log_eek, names_from = n) %&gt;%\n      drop_na(`1`, `2`)\n      \n      fml = str_glue(\"{meas_fn} ~ `2`\") %&gt;% formula()\n      \n      list(tf_loc_id = tf_loc_id, fml = fml)\n  } \n  \n  .create_mm_model &lt;- function(model_obj) {\n    n &lt;- labels(terms(model_obj$fml)) %&gt;% length() \n    \n    ms_ols_model &lt;- lm(formula = model_obj$fml,\n                       data  = model_obj$tf_loc_id) \n    \n    ms_model &lt;- msmFit(ms_ols_model,\n                       k = 2,\n                       p = 0,\n                       sw = rep(TRUE, n + 2), \n                       control = list(trace = FALSE, parallelization = TRUE))\n  }\n  \n  .process_mm_model &lt;- function(model_obj, ms_model, meas_fn) {\n    smoTransMatrob &lt;- model_obj$tf_loc_id %&gt;%  \n      select(id, rs_start, {{ meas_fn }}) %&gt;% add_row(id = NA,  .before = 1) %&gt;%\n      cbind(. ,ms_model@Fit@smoProb)\n    \n    fault_regime &lt;- get_fault_regime(smoTransMatrob, meas_fn)\n    \n    list(smoTransMatrob = smoTransMatrob,\n         smoTransMat = ms_model@Fit@smoTransMat, \n         k = ms_model@k, \n         fault_regime = fault_regime)\n  }\n  \n  model_obj &lt;- .create_objects_for_model(tf_loc_id, meas_fn)\n  ms_model &lt;- .create_mm_model(model_obj)\n  \n  .process_mm_model(model_obj, ms_model, meas_fn)\n}\n\n\nget_model_status &lt;- function(loc_id, \n                                  model_code,\n                                  print_error = TRUE,\n                                  model = \"mm_arm_brkt\",\n                                  object = \"smoTransMatrob\") {\n  \n  .print_err &lt;- function(message = \"Error\", print_error = TRUE){\n    if (print_error) print(str_glue(\"{message} in {loc_id}\")) \n    return(NULL) \n  }\n  \n  models_tool %&gt;%\n    pull({{ model }}) %&gt;% \n    pluck(1, object) %||% .print_err(print_error = print_error)\n}\n\n\nmodel_status_defs &lt;- function(type) {\n  switch(type,\n         \"named list\" = NA, # success\n         \"list\" = NA, # missing in configuration\n         \"lgl\" = \"Error\" # processing error\n  )\n}\n\n\nget_fault_regime &lt;- function(smoTransMatrob, meas_fn = \"x\" ) {\n  regime_corr &lt;- smoTransMatrob %&gt;% \n    select({{ meas_fn }}, `1`, `2`) %&gt;% \n    round(5) %&gt;% \n    cor(use = \"complete.obs\")\n  \n  which.max(regime_corr[1, 2:3]) \n}\n\n\nget_model_fails &lt;- function(path, loc_id, prob_thres, daysback, model, meas_fn, faults_only = TRUE) {\n  subset_dummy &lt;- list()\n  \n  for (loc_id in loc_ids) {\n    \n    models_tool &lt;- readRDS(file = str_glue(\"{path}/models/model_object_{loc_id}.rds\")) \n    \n    smoTransMatrob &lt;- get_model_status(loc_id,\n                                            models_tool,\n                                            print_error = FALSE, \n                                            model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                            object = \"smoTransMatrob\") %||% next\n    fault_regime &lt;- get_model_status(loc_id,\n                                          models_tool,\n                                          print_error = FALSE, \n                                          model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                          object = \"fault_regime\") %||% next\n    \n    smoTransMatrob &lt;- smoTransMatrob %&gt;% \n      mutate(tool_name = loc_id,\n             fault_prob =!!as.symbol(fault_regime), \n             fault_prob = round(fault_prob, 5)) %&gt;% \n      filter(rs_start &gt; Sys.Date() - daysback)\n    \n    if (faults_only) {\n      smoTransMatrob &lt;- smoTransMatrob %&gt;% filter(fault_prob &gt;= {{ prob_thres }})  \n    }\n    \n    subset_dummy[[loc_id]] &lt;- smoTransMatrob %&gt;% \n      select(tool_name, id, {{ meas_fn }}, rs_start, fault_prob)\n    \n  }\n  \n  do.call(rbind, subset_dummy) %&gt;% remove_rownames() \n}"
  },
  {
    "objectID": "fault_diagnostics.html#evaluate-fit",
    "href": "fault_diagnostics.html#evaluate-fit",
    "title": "4  Fault Diagnostics",
    "section": "4.5 Evaluate Fit",
    "text": "4.5 Evaluate Fit\n\n\nretrieve_model_obj &lt;- function(path, loc_id, model, meas_fn) {\n  \n  models_tool &lt;- readRDS(file = str_glue(\"{path}/models/model_object_{loc_id}.rds\")) \n  \n  smoTransMatrob &lt;- get_model_status(loc_id,\n                                          models_tool,\n                                          print_error = FALSE, \n                                          model = str_glue(\"mm_{model}_{meas_fn}\"), \n                                          object = \"smoTransMatrob\")\n  smoTransMat &lt;- get_model_status(loc_id,\n                                       models_tool, \n                                       print_error = FALSE, \n                                       model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                       object = \"smoTransMat\")\n  fault_regime &lt;- get_model_status(loc_id,\n                                        models_tool,\n                                        print_error = FALSE, \n                                        model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                        object = \"fault_regime\")\n  k &lt;- get_model_status(loc_id,\n                             models_tool,\n                             print_error = FALSE, \n                             model = str_glue(\"mm_{model}_{meas_fn}\"),\n                             object = \"k\")\n  \n  list(smoTransMatrob = smoTransMatrob,\n       smoTransMat = smoTransMat, \n       k = k, \n       fault_regime = fault_regime)\n}\n\n\nfilter_fault_freq &lt;- function(tbl, number_of_fails) {\n  tbl %&gt;%   \n    mutate(number_of_fails = n()) %&gt;% \n    filter(number_of_fails &gt;=!!number_of_fails) \n}\n\nfilter_fault_freq_group &lt;- function(tbl, groups = c(\"fac\", \"tool_name\"), number_of_fails) {\n  tbl %&gt;%\n    group_by(across(all_of(groups))) %&gt;% \n    filter_fault_freq(number_of_fails) %&gt;%\n    distinct(across(all_of(groups)))\n}"
  },
  {
    "objectID": "fault_diagnostics.html#chapman-kolmogorov",
    "href": "fault_diagnostics.html#chapman-kolmogorov",
    "title": "4  Fault Diagnostics",
    "section": "4.6 Chapman-Kolmogorov",
    "text": "4.6 Chapman-Kolmogorov\n\n\ncalc_trans_mat &lt;- function(path, loc_id, model, meas_fn, t_steps = 1L) {\n  model_obj &lt;- retrieve_model_obj(path, loc_id, model, meas_fn)\n  \n  smoTransMatrob &lt;- model_obj$smoTransMatrob %&gt;% select(`1`, `2`) \n  smoTransMat &lt;- model_obj$smoTransMat\n  k &lt;- model_obj$k\n  fault_regime &lt;- model_obj$fault_regime\n  \n  gamma_t_s &lt;- matrix(apply(matrix(unlist(smoTransMat),nrow = k*k),1,sum)/rep(apply(smoTransMatrob[-1,],2,sum),rep(k,k)),ncol = k)\n  dimnames(gamma_t_s) &lt;- switch(fault_regime, \"1\" = rep(list(c(\"Fault\", \"Stable\")),2), \"2\" = rep(list(c(\"Stable\", \"Fault\")),2))\n  \n  if (t_steps &lt;= 2) return(gamma_t_s)\n  \n  gamma_t &lt;- matrix(apply(matrix(unlist(smoTransMat[1:t_steps]),nrow = k*k),1,sum)/rep(apply(head(smoTransMatrob[-1,], t_steps),2,sum),rep(k,k)),ncol = k)\n  \n  gamma_s &lt;- gamma_t_s %*% MASS::ginv(gamma_t)\n  gamma_s &lt;- abs(kronecker(gamma_s, k-1)) # This should hold true for MP invertibility\n  gamma_s &lt;- t(t(gamma_s) / apply(gamma_s, 2, sum))\n  dimnames(gamma_s) &lt;- switch(fault_regime, \"1\" = rep(list(c(\"Fault\", \"Stable\")),2), \"2\" = rep(list(c(\"Stable\", \"Fault\")),2))\n  \n  .check_topmap &lt;- function(gamma_s) {\n    evec &lt;- eigen(gamma_s)$vectors\n    t(evec[, 1]) %*% evec[, 2] &lt;= abs(evec[, 1]) %*% abs(evec[, 2])\n  }\n  \n  .check_statdist &lt;- function(gamma_x) {\n    m &lt;- dim(gamma_x)[1]\n    stat_dist &lt;- matrix(1, 1, m) %*% solve(diag(1, m) - gamma_x + matrix(1, m, m))\n    \n    all.equal(eigen(gamma_x)$values, as.vector(stat_dist)) &lt; sqrt(.Machine$double.eps)\n  }\n  \n  if (!.check_topmap(gamma_s) | .check_statdist(gamma_s)) return(gamma_t_s)\n  \n  gamma_s\n}"
  },
  {
    "objectID": "fault_diagnostics.html#lstm-ae",
    "href": "fault_diagnostics.html#lstm-ae",
    "title": "4  Fault Diagnostics",
    "section": "4.3 LSTM AE",
    "text": "4.3 LSTM AE"
  },
  {
    "objectID": "fault_diagnostics.html#hmm",
    "href": "fault_diagnostics.html#hmm",
    "title": "4  Fault Diagnostics",
    "section": "4.4 HMM",
    "text": "4.4 HMM\n\n\nget_mm_results &lt;- function(tf_loc_id, meas_fn) {\n  .create_objects_for_model &lt;- function(tf_loc_id, meas_fn) {\n    tf_loc_id &lt;- tf_loc_id %&gt;%\n      unnest(gi) %&gt;% \n      ungroup()\n    \n    tf_loc_id &lt;- tf_loc_id %&gt;% \n      unnest(str_glue(\"ie_{meas_fn}\")) %&gt;% \n      select(id, rs_start, n, log_eek, {{ meas_fn }}) %&gt;%\n      filter(n() &gt;= 2) %&gt;% \n      pivot_wider(values_from = log_eek, names_from = n) %&gt;%\n      drop_na(`1`, `2`)\n      \n      fml = str_glue(\"{meas_fn} ~ `2`\") %&gt;% formula()\n      \n      list(tf_loc_id = tf_loc_id, fml = fml)\n  } \n  \n  .create_mm_model &lt;- function(model_obj) {\n    n &lt;- labels(terms(model_obj$fml)) %&gt;% length() \n    \n    ms_ols_model &lt;- lm(formula = model_obj$fml,\n                       data  = model_obj$tf_loc_id) \n    \n    ms_model &lt;- msmFit(ms_ols_model,\n                       k = 2,\n                       p = 0,\n                       sw = rep(TRUE, n + 2), \n                       control = list(trace = FALSE, parallelization = TRUE))\n  }\n  \n  .process_mm_model &lt;- function(model_obj, ms_model, meas_fn) {\n    smoTransMatrob &lt;- model_obj$tf_loc_id %&gt;%  \n      select(id, rs_start, {{ meas_fn }}) %&gt;% add_row(id = NA,  .before = 1) %&gt;%\n      cbind(. ,ms_model@Fit@smoProb)\n    \n    fault_regime &lt;- get_fault_regime(smoTransMatrob, meas_fn)\n    \n    list(smoTransMatrob = smoTransMatrob,\n         smoTransMat = ms_model@Fit@smoTransMat, \n         k = ms_model@k, \n         fault_regime = fault_regime)\n  }\n  \n  model_obj &lt;- .create_objects_for_model(tf_loc_id, meas_fn)\n  ms_model &lt;- .create_mm_model(model_obj)\n  \n  .process_mm_model(model_obj, ms_model, meas_fn)\n}\n\n\nget_model_status &lt;- function(loc_id, \n                                  model_code,\n                                  print_error = TRUE,\n                                  model = \"mm_arm_brkt\",\n                                  object = \"smoTransMatrob\") {\n  \n  .print_err &lt;- function(message = \"Error\", print_error = TRUE){\n    if (print_error) print(str_glue(\"{message} in {loc_id}\")) \n    return(NULL) \n  }\n  \n  models_tool %&gt;%\n    pull({{ model }}) %&gt;% \n    pluck(1, object) %||% .print_err(print_error = print_error)\n}\n\n\nmodel_status_defs &lt;- function(type) {\n  switch(type,\n         \"named list\" = NA, # success\n         \"list\" = NA, # missing in configuration\n         \"lgl\" = \"Error\" # processing error\n  )\n}\n\n\nget_fault_regime &lt;- function(smoTransMatrob, meas_fn = \"x\" ) {\n  regime_corr &lt;- smoTransMatrob %&gt;% \n    select({{ meas_fn }}, `1`, `2`) %&gt;% \n    round(5) %&gt;% \n    cor(use = \"complete.obs\")\n  \n  which.max(regime_corr[1, 2:3]) \n}\n\n\nget_model_fails &lt;- function(path, loc_id, prob_thres, daysback, model, meas_fn, faults_only = TRUE) {\n  subset_dummy &lt;- list()\n  \n  for (loc_id in loc_ids) {\n    \n    models_tool &lt;- readRDS(file = str_glue(\"{path}/models/model_object_{loc_id}.rds\")) \n    \n    smoTransMatrob &lt;- get_model_status(loc_id,\n                                            models_tool,\n                                            print_error = FALSE, \n                                            model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                            object = \"smoTransMatrob\") %||% next\n    fault_regime &lt;- get_model_status(loc_id,\n                                          models_tool,\n                                          print_error = FALSE, \n                                          model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                          object = \"fault_regime\") %||% next\n    \n    smoTransMatrob &lt;- smoTransMatrob %&gt;% \n      mutate(tool_name = loc_id,\n             fault_prob =!!as.symbol(fault_regime), \n             fault_prob = round(fault_prob, 5)) %&gt;% \n      filter(rs_start &gt; Sys.Date() - daysback)\n    \n    if (faults_only) {\n      smoTransMatrob &lt;- smoTransMatrob %&gt;% filter(fault_prob &gt;= {{ prob_thres }})  \n    }\n    \n    subset_dummy[[loc_id]] &lt;- smoTransMatrob %&gt;% \n      select(tool_name, id, {{ meas_fn }}, rs_start, fault_prob)\n    \n  }\n  \n  do.call(rbind, subset_dummy) %&gt;% remove_rownames() \n}"
  },
  {
    "objectID": "fault_diagnostics.html#evaluate-hmm-fit",
    "href": "fault_diagnostics.html#evaluate-hmm-fit",
    "title": "4  Fault Diagnostics",
    "section": "4.5 Evaluate HMM Fit",
    "text": "4.5 Evaluate HMM Fit\n\n\nretrieve_model_obj &lt;- function(path, loc_id, model, meas_fn) {\n  \n  models_tool &lt;- readRDS(file = str_glue(\"{path}/models/model_object_{loc_id}.rds\")) \n  \n  smoTransMatrob &lt;- get_model_status(loc_id,\n                                          models_tool,\n                                          print_error = FALSE, \n                                          model = str_glue(\"mm_{model}_{meas_fn}\"), \n                                          object = \"smoTransMatrob\")\n  smoTransMat &lt;- get_model_status(loc_id,\n                                       models_tool, \n                                       print_error = FALSE, \n                                       model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                       object = \"smoTransMat\")\n  fault_regime &lt;- get_model_status(loc_id,\n                                        models_tool,\n                                        print_error = FALSE, \n                                        model = str_glue(\"mm_{model}_{meas_fn}\"),\n                                        object = \"fault_regime\")\n  k &lt;- get_model_status(loc_id,\n                             models_tool,\n                             print_error = FALSE, \n                             model = str_glue(\"mm_{model}_{meas_fn}\"),\n                             object = \"k\")\n  \n  list(smoTransMatrob = smoTransMatrob,\n       smoTransMat = smoTransMat, \n       k = k, \n       fault_regime = fault_regime)\n}\n\n\nfilter_fault_freq &lt;- function(tbl, number_of_fails) {\n  tbl %&gt;%   \n    mutate(number_of_fails = n()) %&gt;% \n    filter(number_of_fails &gt;=!!number_of_fails) \n}\n\nfilter_fault_freq_group &lt;- function(tbl, groups = c(\"fac\", \"tool_name\"), number_of_fails) {\n  tbl %&gt;%\n    group_by(across(all_of(groups))) %&gt;% \n    filter_fault_freq(number_of_fails) %&gt;%\n    distinct(across(all_of(groups)))\n}"
  },
  {
    "objectID": "fault_diagnostics.html#chapman-kolmogorov-adjustments",
    "href": "fault_diagnostics.html#chapman-kolmogorov-adjustments",
    "title": "4  Fault Diagnostics",
    "section": "4.6 Chapman-Kolmogorov Adjustments",
    "text": "4.6 Chapman-Kolmogorov Adjustments\n\n\ncalc_trans_mat &lt;- function(path, loc_id, model, meas_fn, t_steps = 1L) {\n  model_obj &lt;- retrieve_model_obj(path, loc_id, model, meas_fn)\n  \n  smoTransMatrob &lt;- model_obj$smoTransMatrob %&gt;% select(`1`, `2`) \n  smoTransMat &lt;- model_obj$smoTransMat\n  k &lt;- model_obj$k\n  fault_regime &lt;- model_obj$fault_regime\n  \n  gamma_t_s &lt;- matrix(apply(matrix(unlist(smoTransMat),nrow = k*k),1,sum)/rep(apply(smoTransMatrob[-1,],2,sum),rep(k,k)),ncol = k)\n  dimnames(gamma_t_s) &lt;- switch(fault_regime, \"1\" = rep(list(c(\"Fault\", \"Stable\")),2), \"2\" = rep(list(c(\"Stable\", \"Fault\")),2))\n  \n  if (t_steps &lt;= 2) return(gamma_t_s)\n  \n  gamma_t &lt;- matrix(apply(matrix(unlist(smoTransMat[1:t_steps]),nrow = k*k),1,sum)/rep(apply(head(smoTransMatrob[-1,], t_steps),2,sum),rep(k,k)),ncol = k)\n  \n  gamma_s &lt;- gamma_t_s %*% MASS::ginv(gamma_t)\n  gamma_s &lt;- abs(kronecker(gamma_s, k - 1)) # true for MP invertibility\n  gamma_s &lt;- t(t(gamma_s) / apply(gamma_s, 2, sum))\n  dimnames(gamma_s) &lt;- switch(fault_regime, \"1\" = rep(list(c(\"Fault\", \"Stable\")),2), \"2\" = rep(list(c(\"Stable\", \"Fault\")),2))\n  \n  .check_statdist &lt;- function(gamma_x) { # check stationarity\n    m &lt;- dim(gamma_x)[1]\n    stat_dist &lt;- matrix(1, 1, m) %*% solve(diag(1, m) - gamma_x + matrix(1, m, m))\n    \n    all.equal(eigen(gamma_x)$values, as.vector(stat_dist)) &lt; sqrt(.Machine$double.eps)\n  }\n  \n  if (.check_statdist(gamma_s)) return(gamma_t_s)\n  \n  gamma_s\n}"
  }
]